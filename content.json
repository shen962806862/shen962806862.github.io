{"meta":{"title":"小涵の米奇妙妙屋","subtitle":"","description":"","author":"Szh","url":"https://www.hanhan0223.cn","root":"/"},"pages":[{"title":"分类","date":"2022-01-08T09:17:16.000Z","updated":"2022-01-10T01:10:11.487Z","comments":true,"path":"categories/index.html","permalink":"https://www.hanhan0223.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-01-08T09:15:58.000Z","updated":"2022-01-10T01:13:11.227Z","comments":true,"path":"tags/index.html","permalink":"https://www.hanhan0223.cn/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2022-01-07T11:49:11.000Z","updated":"2022-03-02T08:55:22.382Z","comments":true,"path":"about/index.html","permalink":"https://www.hanhan0223.cn/about/index.html","excerpt":"","text":"​ 杭电计算机研一在读。 ​ 摸鱼时间搭个静态网站，学习一下前端相关的东西（主要是云服务器要到期了，没折扣续不起了==）。 ​ To be continued … 2022.3.2今天和师兄们聊了聊研三的毕业情况，再次警醒，最近又懈怠了。 没有那么多时间给你浪费的，时间一直很紧张，放松可以，不能真当自己摆烂了。 还有一大堆的演讲作业没完成，数据结构和算法题需要提上日程了，数字图像处理的书还没有看完，健身也该开始了，党政、国家相关的新闻、知识还需要进一步的深入了解和思考。。。。 问题太多了，怎么能有时间一直打游戏刷b站的呢。 既然给自己套上了枷锁，既然想真正独立，那就得负重前行，路是自己选的。加油吧！ （摸鱼时间里的随手一记）"}],"posts":[{"title":"opencv图像算法","slug":"opencv图像算法","date":"2021-12-23T11:36:24.000Z","updated":"2022-03-16T09:00:39.353Z","comments":true,"path":"原理/opencv图像算法/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/","excerpt":"图像低通滤波邻域滤波 中值滤波图像的中值滤波是一种非线性图像处理方法,是统计排序滤波器的一种典型应用。中值滤波是通过对邻域内像素按灰度排序的结果决定中心像素的灰度。具体的操作过程如下：用一个奇数点的移动窗口，将窗口中心点的值用窗口内各点的中值代替。假设窗口内有5个点，其值为1,2,3,4和5，那么此窗口内各点的中值即为3，也就是用3来代替中心点的像素值。 中值滤波对于滤除脉冲干扰及图像扫描噪声最为有效，还可以克服线性滤波器（如领域简单平滑滤波）带来的图像细节模糊。","text":"图像低通滤波邻域滤波 中值滤波图像的中值滤波是一种非线性图像处理方法,是统计排序滤波器的一种典型应用。中值滤波是通过对邻域内像素按灰度排序的结果决定中心像素的灰度。具体的操作过程如下：用一个奇数点的移动窗口，将窗口中心点的值用窗口内各点的中值代替。假设窗口内有5个点，其值为1,2,3,4和5，那么此窗口内各点的中值即为3，也就是用3来代替中心点的像素值。 中值滤波对于滤除脉冲干扰及图像扫描噪声最为有效，还可以克服线性滤波器（如领域简单平滑滤波）带来的图像细节模糊。 数字图像存在冗余信息，具体分为六大冗余：空间冗余、时间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余。其中第一个空间冗余就可以很好的解释中值滤波的作用。空间冗余指的是：图像内部相邻像素之间存在较强的相关性而造成的冗余。简单来说就是，同一景物表面上采样点的颜色之间通常存在着空间相关性，相邻各点的取值往往相近或者相同，这就是空间冗余。而脉冲噪声通常是在一个邻域内有一个点或多个点的灰度值很高或很低，这就与周围像素存在较大差异，因此中值滤波能很好的去除这种噪声。 需要注意的是，中值滤波的窗口形状和尺寸对滤波效果影响很大，不同的图像内容和不同的应用要求，往往采用不同的窗口形状和尺寸。常用的中值滤波窗口有线状、方形、圆形、十字形以及圆环形等等。窗口尺寸一般先用3x3,再取5x5逐渐增大，直到滤波效果满意为止。就一般经验来讲，对于有缓变的较长轮廓线物体的图像，采用方形或圆形窗口为宜。对于包含有尖顶物体的图像，用十字形窗口，而窗口大小则以不超过图像中最小有效物体的尺寸为宜。如果图像中点、线、尖角细节较多（感觉就是邻域灰度值变化较大），则不宜采用中值滤波。 自适应中值滤波上面提到常规的中值滤波器，在噪声的密度不是很大的情况下，效果不错。但是密度较高时，常规的中值滤波的效果就不是很好了。有一个选择就是增大滤波器的窗口大小，这虽然在一定程度上能解决上述的问题，但是会给图像造成较大的模糊。 常规的中值滤波器的窗口尺寸是固定大小不变的，就不能同时兼顾去噪和保护图像的细节。这时就要寻求一种改变，根据预先设定好的条件，在滤波的过程中，动态的改变滤波器的窗口尺寸大小，这就是自适应中值滤波器 。在滤波的过程中，自适应中值滤波器会根据预先设定好的条件，改变滤波窗口的尺寸大小，同时还会根据一定的条件判断当前像素是不是噪声，如果是则用邻域中值替换掉当前像素；不是，则不作改变。 自适应中值滤波器有三个目的： 滤除椒盐噪声 平滑其他非脉冲噪声 尽可能的保护图像中细节信息，避免图像边缘的细化或者粗化。 实现过程： 对于每一个像素点的处理，使用一个while循环。在while循环中： 首先，在当前像素点下根据当前尺寸窗口的大小获取数据存入数组； 其次，获取窗口内像素的最大最小值和中值； 再，得到A1（中值 - 最小值），A2（中值 - 最大值）。 预先定义好以下符号： Sxy： 滤波器的作用区域，滤波器窗口所覆盖的区域；Zmin： Sxy中最小的灰度值；Zmax： Sxy中最大的灰度值；Zmed： Sxy中所有灰度值的中值；Zxy： 表示图像中对应像素点的灰度值；Smax： Sxy所允许的最大窗口尺寸； 自适应中值滤波器分为以下两个过程，A和B： A: A1 = Zmed - Zmin A2 = Zmed - Zmax 如果A1&gt;0 且 A2&lt;0，则跳转到B 否则，增大窗口的尺寸 如果增大后的尺寸 ≤ Smax，则重复A 否则，直接输出Zmed B： B1 = Zxy - Zmin B2 = Zxy - Zmax 如果B1&gt;0 且 B2&lt;0，则输出Zxy 否则输出Zmed 实现原理： A步骤实质是判断当前区域的中值点是否是噪声点，通常来说是满足条件的，此时中值点不是噪声点，跳转到B；考虑一些特殊情况，如果Zmed=Zmin或者Zmed=Zmax，则认为是噪声点，应该扩大窗口尺寸，在一个更大的范围内寻找一个合适的非噪声点，随后再跳转到B，否则输出的中值点是噪声点； 接下来考虑跳转到B之后的情况：判断中心点的像素值是否是噪声点，原理同上，因为如果Zxy=Zmin或者Zxy=Zmax，则认为是噪声点。如果不是噪声点，我们可以保留当前像素点的灰度值；如果是噪声点，则使用中值替代原始灰度值，滤去噪声。 均值滤波一种特殊形式的邻域滤波（邻域算子都是1/M*N）。 图片中一个方块区域（一般为3*3）内，中心点的像素为全部点像素值的平均值。均值滤波就是对于整张图片进行以上操作。 缺陷：均值滤波本身存在着固有的缺陷，即它不能很好地保护图像细节，在图像去噪的同时也破坏了图像的细节部分，从而使图像变得模糊，不能很好地去除噪声点。特别是椒盐噪声 算术均值滤波这是最简单的均值滤波器，可以去除均匀噪声和高斯噪声，但会对图像造成一定程度的模糊。 算术均值滤波器就是简单的计算窗口区域的像素均值，然后将均值赋值给窗口中心点处的像素： 其中，g(s,t)表示原始图像，f(x,y)表示均值滤波后得到的图像，Sxy表示滤波器窗口。 基于上述公式，可以很容易的得到的算术均值滤波器的窗口模板，下面以3×3为例： 几何均值滤波滤波后图像的像素由模板窗口内像素的乘积的1/mn幂给出。 和算术均值滤波器相比，几何均值滤波器能够更好的取出高斯噪声，并且能够更多的保留图像的边缘信息。但其对0值是非常敏感的，在滤波器的窗口内只要有一个像素的灰度值为0，就会造成滤波器的输出结果为0。 公式如下： 谐波均值滤波对盐粒噪声（白噪声）效果较好，不适用于胡椒噪声；比较适合处理高斯噪声。 公式如下： 逆谐波均值滤波 其中Q称为滤波器的阶数，该滤波器可以用来消除椒盐噪声。但是不能同时处理盐粒噪声和胡椒噪声，当Q为正时，可以消除胡椒噪声；当Q为负时，消除盐粒噪声。当Q=0时，该滤波器退化为算术均值滤波器；Q=-1时，退化为谐波均值滤波器。 修正后的alpha均值滤波假设在Sxy模板领域内，去掉g(s,t)中最高灰度值的d/2和最低灰度值的d/2个像素。用gr(s,t)来代替剩余的mn-d个像素。由剩余像素点的平均值形成的滤波器称为修正后的alpha均值滤波器： 其中d取0~m*n-1之间的任意数。 当d=0时，退变为算术均值滤波； 当d=(m*n-1)，退变为中值滤波器； d取其他值时，该滤波器适用于包括多种噪声的情况，如高斯噪声和椒盐噪声混合的情况。 最值滤波最大值和最小值滤波最值滤波就是取kernal排序后得最大值或最小值来取代中心像素作为输出。 分为最大值滤波和最小值滤波，分别相当于形态学操作的膨胀和腐蚀。 中点滤波在上述最值滤波的基础上，取最大值和最小值的平均值作为中心像素点的输出。 双边滤波双边滤波是一种非线性滤波器，它可以达到保持边缘、降噪平滑的效果。和其他滤波原理一样，双边滤波也是采用加权平均的方法，用周边像素亮度值的加权平均代表某个像素的强度，所用的加权平均基于高斯分布[1]。最重要的是，双边滤波的权重不仅考虑了像素的欧氏距离（如普通的高斯低通滤波，只考虑了位置对中心像素的影响），还考虑了像素范围域中的辐射差异（例如卷积核中像素与中心像素之间相似程度、颜色强度，深度距离等），在计算中心像素的时候同时考虑这两个权重。它是一种可以保边去噪的滤波器。之所以可以达到此去噪效果，是因为滤波器是由两个函数构成。一个函数是由几何空间距离决定滤波器系数。另一个由像素差值决定滤波器系数。 双边滤波的核函数是空间域核与像素范围域核的综合结果：在图像的平坦区域，像素值变化很小，对应的像素范围域权重接近于1，此时空间域权重起主要作用，相当于进行高斯模糊；在图像的边缘区域，像素值变化很大，像素范围域权重变大，从而保持了边缘的信息。 空间域公式如下： 像素范围域（颜色域）公式如下： 他们的乘积即为双边滤波的权重： 根据权重计算最后目标点的像素值： 高斯滤波高斯滤波器是一种线性滤波器，能够有效的抑制噪声，平滑图像。其作用原理和均值滤波器类似，都是取滤波器窗口内的像素的均值作为输出。其窗口模板的系数和均值滤波器不同，均值滤波器的模板系数都是相同的为1；而高斯滤波器的模板系数，则随着距离模板中心的增大而系数减小。所以，高斯滤波器相比于均值滤波器对图像个模糊程度较小。 高斯滤波器 二维高斯函数如下： 其中e前的参数可以忽略，因为这只是个表示幅值的常数，并不影响相互之间的比例关系，并且最终都要进行归一化，所以实际只需要计算后半部分即可。该参数仅影响图像的亮度而不影响模糊。 例如，要产生一个3×3的高斯滤波器模板，以模板的中心位置为坐标原点进行取样。模板在各个位置的坐标，如下所示（x轴水平向右，y轴竖直向下） 对于窗口模板的大小为 (2k+1)×(2k+1)，模板中各个元素值的计算公式如下： 转化为代码： for(int i = 0; i &lt; m; ++i) for(int j = 0; j &lt; n; ++j) double g = exp(((i - m/2)*(i - m/2) + (j - n/2)*(j - n/2)) * -1.0 / (2 * sigma * sigma)); 再对求出来的每个g进行归一化（因为求的是加权平均，要保证窗口模板各元素和为1） kernel = g / sum; 关于高斯分布的标准差σ的选值，代表着数据的离散程度。如果σ较小，那么生成的模板的中心系数较大，而周围的系数较小，这样对图像的平滑效果就不是很明显；反之，σ较大，则生成的模板的各个系数相差就不是很大，比较类似均值模板，对图像的平滑效果比较明显。 高斯分布的概率分布密度图如下： 横轴表示可能得取值x，竖轴表示概率分布密度F(x)，那么不难理解这样一个曲线与x轴围成的图形面积为1。σσ（标准差）决定了这个图形的宽度，可以得出这样的结论：σσ越大，则图形越宽，尖峰越小，图形较为平缓；σσ越小，则图形越窄，越集中，中间部分也就越尖，图形变化比较剧烈。这其实很好理解，如果sigma也就是标准差越大，则表示该密度分布一定比较分散，由于面积为1，于是尖峰部分减小，宽度越宽（分布越分散）；同理，当σσ越小时，说明密度分布较为集中，于是尖峰越尖，宽度越窄！ 以上求出来的就是模板系数，滤波操作就是分别以图像的每个像素点为中心再根据模板系数求出加权平均像素，作为该点的滤波后像素。比如3x3模板，对选中像素点的外一圈共九个像素点，分别乘以对应位置的模板系数再求和，即为选中点的像素。 高通滤波（边缘检测）如何识别图像边缘？图里面有一条线,左边很亮,右边很暗,那人眼就很容易识别这条线作为边缘.也就是像素的灰度值快速变化的地方 Roberts算子Roberts算子是一种最简单的算子，利用局部差分寻找边缘的算子。采用对角线相邻两像素之差近似梯度幅值检测边缘。检测垂直边缘的效果比斜向边缘要好，定位精度高，对噪声比较敏感，无法抑制噪声的影响。 Roberts边缘算子是一个2x2的模板，采用的是对角方向相邻的两个像素之差。从图像处理的实际效果来看，边缘定位较准，对噪声敏感。模板如下： 对于输入图像f(x,y),使用Roberts算子后输出的目标图像为g(x,y),则 Sobel算子（一阶导数法）基于寻找梯度强度 对于f(t),其导数f’(t)反映了每一处的变化趋势.在变化最快的位置其导数最大. sobel算子的思路就是模拟求一阶导数. sobel算子是一个离散差分算子.它计算图像像素点亮度值的近似梯度。图像是二维的,即沿着宽度/高度两个方向。我们使用两个卷积核对原图像进行处理: 水平方向： 原始像素灰度值–&gt;(右边像素值-左边像素值),反映了水平方向的变化情况. 垂直方向同理： 这样就得到了两个新的矩阵,分别反映了每一点像素在水平方向上的亮度变化情况和在垂直方向上的亮度变换情况。 综合考虑这两个方向的变化，使用反映某个像素的梯度变化情况. 有时候为了简单起见,也直接用绝对值相加替代： 在opencv中也可以通过以下卷积核（Scharr）大像素的变化情况： 与滤波一样，对每个像素点的处理为：要操作像素点对应于Gx，Gy矩阵中心，对该像素点和周边9个像素点乘以相应系数求和，得到一个方向上的处理结果。完整的Sobel算子则需要对两个方向上的处理结果求和，得到完整的新像素值。 Prewitt算子Prewitt算子的原理和sobel是一模一样的，唯一的区别就是卷积核存在差异： Sobel相较于Prewitt，在中心权值上使用2来代替1，这样可以较好的抑制噪声。 Laplacian算子（二阶微分法）基于过零点检测 对Sobel算子中的一阶导数函数再次求导可得： 二阶差分公式： Laplace算子的差分形式： 分别对Laplace算子x,y两个方向的二阶导数进行差分就得到了离散函数的Laplace算子。在一个二维函数f(x,y)中，x,y两个方向的二阶差分分别为： 于是可得Laplace算子的差分形式为： 写作滤波模板的形式如下： 注意该模板的特点，在上下左右四个90度的方向上结果相同，也就是说在90度方向上无方向性。为了让该mask在45度的方向上也具有该性质，可以对该模板进行扩展定义为： 注：定义数字形式的拉普拉斯要求系数之和必为0。 之后的操作与其他的空间滤波操作相同。将模板在原图上逐行移动，然后模板中各系数与其重合的像素相乘后求和，赋给与mask中心重合的像素。 拉普拉斯对噪声敏感，会产生双边效果。不能检测出边的方向。通常不直接用于边的检测，只起辅助的角色，检测一个像素是在边的亮的一边还是暗的一边利用零跨越，确定边的位置。 Canny算子图像边缘信息主要集中在高频段，通常说图像锐化或检测边缘，实质就是高频滤波。 微分运算是求信号的变化率，具有加强高频分量的作用。在空域运算中来说，对图像的锐化就是计算微分。由于数字图像的离散信号，微分运算就变成计算差分或梯度。 因此canny算子求边缘点分为以下四步： 1.使用高斯滤波器平滑图像 卷积的核心意义就是获取原始图像中像模板特征的性质。 2.用一阶偏导有限差分（Sobel）计算梯度值和方向 经典Canny算法用了四个梯度算子来分别计算水平，垂直和对角线方向的梯度。但是通常都不用四个梯度算子来分别计算四个方向。常用的边缘差分算子（如Rober，Prewitt，Sobel）计算水平和垂直方向的差分Gx和Gy。这样就可以如下计算梯度模和方向： 梯度角度θ范围从弧度-π到π，然后把它近似到四个方向，分别代表水平，垂直和两个对角线方向（0°,45°,90°,135°）。 由于图像的坐标系是以左上角为原点向右和下延展，因此根据像素点计算出的角度值必然在一、四象限。那么可以分别以 ± π / 8（水平） 、π / 8 ~ 3π / 8（45°）、- π / 8 ~ - 3π / 8（-45°）、一四象限剩余部分（垂直）来分割，落在每个区域的梯度角给一个特定值，代表四个方向之一。 3.对梯度幅值进行非极大值抑制 意义就是寻找像素点局部最大值。 沿着梯度方向，比较它前面和后面的梯度值即可（对于左右边界，则比较附近的两个值）。如果是最大值就保留，否则置为0。 如上图，c点为需要判断的点，按照2中划分的四个区域，可以看到每个区域包含了八邻域中的两个点，通过判断c点的角度值所在区域，与该区域包含的那两个点进行比较即可。 若想提高精度，如上右图：c的角度值在π / 8 ~ 3π / 8（45°）区域，不比较g1和g4，而是比较dTmp1和dTmp2，由于这两个点都是浮点坐标，因此需要采用线性插值方法来计算这两个点的幅值。 通过角度θ可以计算出dTmp1在g1和g2之间的比例，设dis(dTmp1，g2) = w，则dis(g1，dTmp1) = 1 - w。所以dTmp1的幅值为：w * g2 + （1 - w）* g1。同理可得dTmp2的幅值。将c的幅值与这两个浮点坐标的幅值进行比较进行非极大值抑制。 4.用双阈值算法检测、连接边缘 一般的边缘检测算法用一个阈值来滤除噪声或颜色变化引起的小的梯度值，而保留大的梯度值。Canny算法应用双阈值，即一个高阈值和一个低阈值来区分边缘像素。如果边缘像素点梯度值大于高阈值，则被认为是强边缘点。如果边缘梯度值小于高阈值，大于低阈值，则标记为弱边缘点。小于低阈值的点则被抑制掉。 4.5.滞后边界跟踪 强边缘点可以认为是真的边缘。弱边缘点则可能是真的边缘，也可能是噪声或颜色变化引起的。为得到精确的结果，后者引起的弱边缘点应该去掉。通常认为真实边缘引起的弱边缘点和强边缘点是连通的，而又噪声引起的弱边缘点则不会。所谓的滞后边界跟踪算法检查一个弱边缘点的8连通领域像素，只要有强边缘点存在，那么这个弱边缘点被认为是真是边缘保留下来。 只需对所有被标记过的弱边缘点的八邻域进行遍历，若邻域中存在强边缘点，则保留；否则抑制掉。 方向算子方向算子利用一组模板分别计算在不同方向上的差分值，取其中最大的值作为边缘强度，而将与之对应的方向作为边缘方向。 Kirsch算子类似于Sobel算子，也利用图像中某点的梯度幅值作为像素的灰度值，Sobel算子计算出某点两个方向的梯度值，Gx、Gy；但Kirsch算子 利用8个卷积模板计算出了某点8个方向的梯度幅值和方向，并以最大的卷积值作为该点的灰度值。 对每个像素点都用 这8个模板进行进行卷积（注意，每个卷积值都应取绝对值），求出该点的最大卷积值。 Nevitia算子 池化池化的作用：减少特征图大小，也就是可以减少计算量和所需显存。 平均池化（mean-pooling）即对邻域内特征点只求平均 优缺点：能很好的保留背景，但容易使得图片变模糊 正向传播：邻域内取平均 反向传播：特征值根据领域大小被平均，然后传给每个索引位置 最大池化（max-pooling）即对邻域内特征点取最大 优缺点：能很好的保留纹理特征，一般现在都用最大而很少用平均 正向传播：取邻域内最大，并记住最大值的索引位置，以方便反向传播 反向传播：将特征值填充到正向传播中，值最大的索引位置，其他位置补0 随机池化（stochastic-pooling）只需对邻域中的元素按照其概率值大小随机选择，即元素值大的被选中的概率也大。而不像max-pooling那样，永远只取那个最大值元素。 在区域内，将左图的数值进行归一化处理，即 1/（1+2+3+4）=0.1；2/10=0.2；3/10=0.3；4/10=0.4 正向传播：对矩阵区域求加权平均即可，比如上面图中，池化输出值为：1 * 0.1+2 * 0.2+3 * 0.3+4 * 0.4=3。 反向传播：只需保留前向传播已经记录被选中节点的位置的值，其它值都为0,这和max-pooling的反向传播非常类似。 优点：方法简单，泛化能力更强（带有随机性） 颜色亮度与对比度基础线性变化在查询opencv的亮度与对比度变化算法时，大多是博客都采用的最基础的线性变换： ​ out = in * α + β 其中 α 为对比度的变化，β 为亮度变化。 亮度（β）：像素点的值就是0~255，0为黑表示最暗，255为白表示最亮。因此调节亮度就是简单的对像素值进行增减即可，即 β ∈ (-100，-100) 。 对比度（α）：这里就存在问题了，线性变化的对比度调节非常不明显，在视觉上依旧呈现的是亮度的变化，在进行代码编写的时候一直达不到Photoshop里面的对比度调节效果。 改进通过查阅资料不难发现，对比度的调节原理如下： 对比度反应了图片上亮区域和暗区域的层次感。而反应到图像编辑上，调整对比度就是在保证平均亮度不变的情况下，扩大或缩小亮的点和暗的点的差异。既然是要保证平均亮度不变，所以对每个点的调整比例必须作用在该值和平均亮度的差值之上，这样才能够保证计算后的平均亮度不变。 因此很容易得出对比度变化的调整公式如下： ​ out = (in - average) * α + in 其中average为图像的平均亮度，α ∈ (-1，1) 。 但是实际处理中，并没有太多的必要去计算一张图的平均亮度：一来耗时间，二来在平均亮度上的精确度并不会给图像的处理带来太多的好处。因此一般假设一张图的平均亮度为127，即一半亮度，而一张正常拍照拍出来的图平均亮度应该是在[100,150]。在视觉上基本没有任何区别。 于是可得最终的亮度对比度调节公式： ​ out = (in - average) * α + in + β 达到了和Photoshop相同的效果。 通道混合也就是调整某一个通道中的颜色成分，可以理解为调整图片某一颜色区域的颜色。 对于选中通道的每一个像素值，进行如下变换： ​ out = red * r + green * g + blue * b + constant * 255 其中，red、green、blue ∈ (-2, 2) ，**constant ∈ (-1, 1)**，r、g、b为每一个像素点的三个通道的值。 gamma变换（校正）Gamma校正是一种非常重要的非线性变换。对输入图像的灰度值进行指数变换，进而校正亮度偏差，通常应用于扩展暗调的细节。gamma校正可使得图像看起来更符合人眼的特性。 但其实Gamma校正不仅会改变亮度，还会改变彩色图像中rgb的比率。 当Gamma校正的值大于1时，图像的高光部分被压缩而暗调部分被扩展，图像整体变暗； 当Gamma校正的值小于1时，图像的高光部分被压缩而暗调部分被压缩，图像整体变亮。 gamma校正的作用： 1.人眼对外界光源的感光值与输入光强不是呈线性关系的，而是呈指数型关系的。在低照度下，人眼更容易分辨出亮度的变化，随着照度的增加，人眼不易分辨出亮度的变化。而摄像机感光与输入光强呈线性关系。 2.为能更有效的保存图像亮度信息。未经Gamma变换和经过Gamma变换保存图像信息如下所示：可以观察到，未经Gamma变换的情况下，低灰度时，有较大范围的灰度值被保存成同一个值，造成信息丢失；同时高灰度值时，很多比较接近的灰度值却被保存成不同的值，造成空间浪费。经过Gamma变换后，改善了存储的有效性和效率。 Gamma校正主要应用在图像增强、目标检测以及图像分析等领域。表达式如下： 代码实现 unsigned char newPixel = static_cast&lt;unsigned char&gt;(pow(pixel / 255.0, gamma) * 255); 图像的归一化所谓归一化，就是把需要处理的数据限制在你需要的一定范围内。 首先归一化是为了后面数据处理的方便，其次是保证程序运行时收敛加快。归一化的具体作用是归纳统一样本的统计分布性。归一化在0-1之间是统计的概率分布，归一化在某个区间上是统计的坐标分布。 而图像的归一化用的最多的就是归一化到（min，max）范围内： 代码实现 首先迭代整个图的像素点，获取max( src( x，y ) )和min像素点。 然后再次迭代整张图的像素点，将低于min的设置为min，高于max 的设置为max，在（min，max）之间的通过上式计算即可。 图像的均衡化直方图均衡化，是对图像像素值进行非线性拉伸，使得一定范围内像素值的数量的大致相同。这样原来直方图中的封顶部分对比度得到了增强，而两侧波谷的对比度降低，输出的直方图是一个较为平坦的分段直方图。如下图所示： 通过这种方法可以按照需要对图像的亮度进行调整，并且，这种方法是可逆的，也就是说知道了均衡化函数，也可以恢复原始的直方图。 为什么要选用累积分布函数? 均衡化过程中，必须要保证两个条件：①像素无论怎么映射，一定要保证原来的大小关系不变，较亮的区域，依旧是较亮的，较暗依旧暗，只是对比度增大，绝对不能明暗颠倒；②如果是八位图像，那么像素映射函数的值域应在0和255之间的，不能越界。综合以上两个条件，累积分布函数是个好的选择，因为累积分布函数是单调增函数（控制大小关系），并且值域是0到1（控制越界问题），所以直方图均衡化中使用的是累积分布函数。 为什么使用累积分布函数处理后像素值会均匀分布？ 比较概率分布函数和累积分布函数，前者的二维图像是参差不齐的，后者是单调递增的。直方图均衡化过程中，映射方法是： 其中，n是图像中像素点的总数，nk是当前灰度级的像素个数，L是图像中可能的灰度级总数。 于是对于像素值为k的点，只需要计算： 像素为0~k的点的数量 / 像素点总数，就可以得到直方图中的纵坐标（比例）。再乘以255，即为该点经过均衡化后的像素点。 RGB转灰度一、基础 对于彩色转灰度，有一个很著名的心理学公式： Gray = R * 0.299 + G * 0.587 + B * 0.114 二、整数算法 而实际应用时，希望避免低速的浮点运算，所以需要整数算法。 注意到系数都是3位精度的没有，我们可以将它们缩放1000倍来实现整数运算算法： Gray = (R * 299 + G * 587 + B * 114 + 500) / 1000 RGB一般是8位精度，现在缩放1000倍，所以上面的运算是32位整型的运算。注意后面那个除法是整数除法，所以需要加上500来实现四舍五入。 三、整数移位算法 上面的整数算法已经很快了，但是有一点仍制约速度，就是最后的那个除法。移位比除法快多了，所以可以将系数缩放成 2的整数幂。 习惯上使用16位精度，2的16次幂是65536，所以这样计算系数： 0.299 * 65536 = 19595.264 ≈ 19595 0.587 * 65536 + (0.264) = 38469.632 + 0.264 = 38469.896 ≈ 38469 0.114 * 65536 + (0.896) = 7471.104 + 0.896 = 7472 这所使用的舍入方式不是四舍五入。四舍五入会有较大的误差，应该将以前的计算结果的误差一起计算进去，舍入方式是去尾法，表达式是： Gray = (R * 19595 + G * 38469 + B * 7472) &gt;&gt; 16 同理，2至20位精度的系数： Gray = (R * 1 + G * 2 + B * 1) &gt;&gt; 2Gray = (R * 2 + G * 5 + B * 1) &gt;&gt; 3Gray = (R * 4 + G * 10 + B * 2) &gt;&gt; 4Gray = (R * 9 + G * 19 + B * 4) &gt;&gt; 5Gray = (R * 19 + G * 37 + B * 8) &gt;&gt; 6Gray = (R * 38 + G * 75 + B * 15) &gt;&gt; 7Gray = (R * 76 + G * 150 + B * 30) &gt;&gt; 8Gray = (R * 153 + G * 300 + B * 59) &gt;&gt; 9Gray = (R * 306 + G * 601 + B * 117) &gt;&gt; 10Gray = (R * 612 + G * 1202 + B * 234) &gt;&gt; 11Gray = (R * 1224 + G * 2405 + B * 467) &gt;&gt; 12Gray = (R * 2449 + G * 4809 + B * 934) &gt;&gt; 13Gray = (R * 4898 + G * 9618 + B * 1868) &gt;&gt; 14Gray = (R * 9797 + G * 19235 + B * 3736) &gt;&gt; 15Gray = (R * 19595 + G * 38469 + B * 7472) &gt;&gt; 16Gray = (R * 39190 + G * 76939 + B * 14943) &gt;&gt; 17Gray = (R * 78381 + G * 153878 + B * 29885) &gt;&gt; 18Gray = (R * 156762 + G * 307757 + B * 59769) &gt;&gt; 19Gray = (R * 313524 + G * 615514 + B * 119538) &gt;&gt; 20 这些精度实际上是一样的：3与4、7与8、10与11、13与14、19与20 所以16位运算下最好的计算公式是使用7位精度，比先前那个系数缩放100倍的精度高，而且速度快 Gray = (R * 38 + G * 75 + B * 15) &gt;&gt; 7 灰度转伪彩色本质就是将灰度值根据一定的比例关系转化为RGB三通道值。 人类能够观察到的光的波长范围是有限的，并且人类视觉有一个特点，只能分辨出二十几种灰度，也就是说即使采集到的灰度图像分辨率超级高，有上百个灰度级，但是很遗憾，人们只能看出二十几个，也就是说信息损失了五十倍。但人类视觉对彩色的分辨能力相当强，能够分辨出几千种色度。 以下为opencv中ColorMap提供的21种不同伪彩色： 根据源码中获得的数组对每个像素进行转换即可。 二值化普通二值化遍历判断图像每个像素点的值，如果大于设定的阈值，则修改为255，如果小于，则修改为0。 大津法二值化图像分割中阈值选取的最佳算法，计算简单，不受图像亮度和对比度的影响。它是按图像的灰度特性，将图像分成背景和前景两部分。因方差是灰度分布均匀性的一种度量，背景和前景之间的类间方差越大，说明构成图像的两部分的差别越大，当部分前景错分为背景或部分背景错分为前景都会导致两部分差别变小。因此,使类间方差最大的分割意味着错分概率最小。 优点：计算简单快速，不受图像亮度和对比度的影响。适用于大部分需要求图像全局阈值的场合。 缺点：对图像噪声敏感；只能针对单一目标分割；当目标和背景大小比例悬殊、类间方差函数可能呈现双峰或者多峰，这个时候效果不好。 实现原理 同样用到了最大类间方差的概念，参考下面双阈值三值化，不再多叙述。 注： 为了快速计算，可将类间方差计算公式：σ^2 = p1 * ( m1 - mg ) ^ 2 + p2 * ( m2 - mg ) ^ 2 简化为：σ^2 = p1 * p2 * ( m1 - m2 ) ^ 2 双阈值三值化首先获取图像像素的直方图，即像素值为0255的点分别有几个，并分别计算它们占总像素点数的比例（即一个点为该像素值的概率，Pi（i=0255））。 其次设定两个阈值k1和k2，将0255分为三类（0k1，k1k2，k2255），计算： 一个点被分为其中一类的概率，表现为该类像素范围内概率的和。 这三类各自的像素均值，表现为： 于是有：mg = p1 * m1 + p2 * m2 + p3 * m3，且 p1+p2+p3 = 1 可得类间方差：（更多或更少类均同理） σ^2 = p1 * ( m1 - mg ) ^ 2 + p2 * ( m2 - mg ) ^ 2 + p3 * ( m3 - mg ) ^ 2 最终目的是为了获得当类间方差最大时的k1和k2 最后只需要判断每个像素点的值在这三类中的哪类，分别修改值为0，128，255即可。 因此代码实现为： for (k1 = 1; k1 &lt; 256; k1++)&#123; for (k2 = 1; k2 &lt; 256; k2++)&#123; for (int i = 0; i &lt; k1; i++)&#123; p1 += Pi; m1 += i * Pi; &#125; for (int i = k1; i &lt; k2; i++)&#123; p2 += Pi; m2 += i * Pi; &#125; for (int i = k2; i &lt; 256; i++)&#123; p3 += Pi; m3 += i * Pi; &#125; mg = m1 + m2 + m3; m1 /= p1; m2 /= p2; m3 /= p3; // 类间方差 double sigma = p1 * pow(m1 - mg, 2) + p2 * pow(m2 - mg, 2) + p3 * pow(m3 - mg, 2); if (max &lt; sigma)&#123; max = sigma; thres1 = k1; thres2 = k2; &#125; &#125; &#125; 几何变换图像的缩放最近邻插值 由于缩放比例（即srcWidth / dstWidth）基本上是浮点数值，而最后得到的图像坐标（srcX）是整数。因此需要对等式右边的值进行四舍五入的操作： int srcX = static_cast&lt;int&gt;(dstX * (srcWidth / dstWidth) + 0.5f); // 其中static_cast用于强制转换为int类型 // +0.5f是为了实现四舍五入而不是舍去小数点后的值 这种方法在放大图像时容易导致图像的严重失真，根源在于当坐标是浮点数时直接四舍五入取最近的整数。 双线性插值线性插值的解释 已知数据 (x0, y0) 与 (x1, y1)，要计算 [x0, x1] 区间内某一位置 x 在直线上的y值。 双线性插值是有两个变量的插值函数的线性插值扩展，其核心思想是在两个方向分别进行一次线性插值。如下图： 假如我们想得到未知函数 f 在点 P = (x, y) 的值，假设我们已知函数 f 在 Q11 = (x1, y1)、Q12 = (x1, y2), Q21 = (x2, y1) 以及 Q22 = (x2, y2) 四个点的值。最常见的情况，f就是一个像素点的像素值。首先在 x 方向进行线性插值，得到： 然后在上述基础上（R1和R2），在 y 方向进行线性插值，得到： 展开即为最终结果： 代码实现 由于图像双线性插值只会用相邻的4个点，因此上述公式的分母都是1。opencv中的源码如下，用了一些优化手段： 用整数计算代替float（下面代码中的 * 2048就是变11位小数为整数，最后有两个连乘，因此&gt;&gt;22位） 源图像和目标图像几何中心的对齐 SrcX=(dstX + 0.5) * (srcWidth/dstWidth) -0.5 SrcY=(dstY + 0.5) * (srcHeight/dstHeight) - 0.5 源图像和目标图像的原点（0，0）均选择左上角，然后根据插值公式计算目标图像每点像素，假设你需要将一幅5x5的图像缩小成3x3，那么源图像和目标图像各个像素之间的对应关系如下。如果没有这个中心对齐，根据基本公式去算，就会得到左边这样的结果；而用了对齐，就会得到右边的结果： 双立方插值邻域像素再取样插值lanczos插值图像的旋转旋转矩阵的计算原理参考： 实现方法： 采用反向映射。即从旋转后的图像出发，找到对应的原图像的点，然后将原图像中的灰度值传递过来即可，这样旋转后的图像的每个像素肯定可以对应到原图像中的一个点。 采用不同的策略算法可以使像素更加准确，*具体参照图像缩放中的各种插值法，在旋转中是同理。 直线拟合 这里只记录最常用的一种：最小二乘拟合算法 这种方法是以距离平方和为拟合判据，运行速度也最快。但是这个算法也有个很大的问题，就是当干扰点离直线较远时，一个干扰点就可能将整条拟合直线拉偏了。简单的说就是对干扰点的鲁棒性不够。 代码实现 假设直线表达式为：y = ax + b，a表示斜率，b表示截距。 对于等精度测量所得到的N组数据（xi，yi），i＝1，2……，N，其中xi值被认为是准确的，所有的误差只联系着yi；用最小二乘法估计参数时，要求观测值yi的偏差的加权平方和为最小。对于等精度观测值的直线拟合来说，可使下式的值最小： 令上式等于D，并分别对a，b求一阶偏导数： 再求二阶偏导数： 很显然二阶偏导数均为非负数，于是令一阶偏导数等于0，解得a和b： 若要转化成方向向量： 因为方向向量长度为1且起点为原点，所以易得：x^2 + a * x^2 = 1，解得： **x = 1 / sqrt( a^2 + 1 ) ** **y = a / sqrt( a^2 + 1 ) ** 即为方向向量。","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://www.hanhan0223.cn/tags/opencv/"},{"name":"图像","slug":"图像","permalink":"https://www.hanhan0223.cn/tags/%E5%9B%BE%E5%83%8F/"}]},{"title":"opencv移库笔记","slug":"opencv移库笔记","date":"2021-12-23T11:28:33.000Z","updated":"2022-01-10T01:10:11.379Z","comments":true,"path":"杂记/opencv移库笔记/","link":"","permalink":"https://www.hanhan0223.cn/%E6%9D%82%E8%AE%B0/opencv%E7%A7%BB%E5%BA%93%E7%AC%94%E8%AE%B0/","excerpt":"环境配置VMware Workstation版本 16.0版本！ 16.0版本！ 16.0版本！15版本的有bug，会闪退。 VMware Tools实现物理机和虚拟机之间的文件和文本的直接复制粘贴 1.点击虚拟机选项中的安装，安装的是个tar.gz的压缩包 2.将虚拟机解压至任意路径下，并在该路径下进入命令行","text":"环境配置VMware Workstation版本 16.0版本！ 16.0版本！ 16.0版本！15版本的有bug，会闪退。 VMware Tools实现物理机和虚拟机之间的文件和文本的直接复制粘贴 1.点击虚拟机选项中的安装，安装的是个tar.gz的压缩包 2.将虚拟机解压至任意路径下，并在该路径下进入命令行 3../vmware-install.pl即可完成安装 Ubuntu16.0版本，用户名和密码设简单点！建议英文！ 切换中文输入法用Ctrl+空格。 解压：tar -zxvf xxx.tar.gz 分辨率cvt 1920 1080 // 返回 # 1920x1080 59.96 Hz (CVT 2.07M9) hsync: 67.16 kHz; pclk: 173.00 MHz Modeline &quot;1920x1080_60.00&quot; 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync // 增加显示模块，并设置为开机启动，编辑”/etc/profile”，在末尾增加： xrandr --newmode &quot;1920x1080_60.00&quot; 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync xrandr --addmode VGA1 &quot;1920x1080_60.00&quot; // 立即启用 source /etc/profile 之后就可以在设置中的Display里修改啦。 opencv库安装与编译下载1.在GitHub上下载了opencv4.1.1的库，并在Ubuntu中解压 2.下载 ippicv_2019_lnx_intel64_general_20180723，这个压缩包无需解压 3.将opencv-4.1.1/3rdparty/ippicv/ippicv.cmake文件中倒数第十行(以http开头的)修改成”file://path“, path为下载的ippicv_2019_lnx_intel64_general_20180723在你的电脑中存放的位置（绝对路径） 安装依赖包sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev 编译opencv在opencv-4.1.1路径下 mkdir build cd build cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local -D OPENCV_GENERATE_PKGCONFIG=ON .. // 这里选择安装路径为/usr/local下，并开启了pkg-config // 因为opencv4开始就不会主动支持pkg-config了，但是编译还是需要这个。 // 一定注意这两个点“..”，这是选择编译的内容为整个opencv文件夹 // 编译结束后进入下一步： make -j8 // 这一步比较久一点，8为选择编译时使用的内核数 sudo make install opencv_version //编译结束后运行，若能查看到版本号就ok了 sudo gedit /etc/ld.so.conf.d/opencv.conf //设置opencv的环境变量。(文件可能为空，即原来不存在，新建立的) //将如下内容添加到最后： /usr/local/lib (依然要对应成你本身的路径，这个看看安装好之后，你的安装路径下的lib文件夹位置) //配置库 sudo ldconfig //更改环境变量： sudo gedit /etc/bash.bashrc //在文件后添加 PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/home/ubun/myinstall/lib/pkgconfig export PKG_CONFIG_PATH opencv 编译后主要文件位于 /usr/local/bin /usr/local/include/opencv4 /usr/local/lib 导入opencv扩展包1.下载opencv_contrib-4.1.1扩展包 2.将文件夹解压至opencv-4.1.1文件夹下，同时删除其下的build文件夹（之前的编译文件） 3.下载可能缺少的.i文件（会导致编译失败） 将下载的.i文件放至**/opencv_4.1.1/opencv_contrib-4.1.1/modules/xfeatures2d/src/**目录下 4.按照上一节的步骤重新编译，其中编译命令做一点改动（增加一句） cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local -D OPENCV_EXTRA_MODULES_PATH=/home/shenzihan/opencv-4.1.1/opencv_contrib-4.1.1/modules/ -D OPENCV_GENERATE_PKGCONFIG=ON .. 5.在执行make -j4时可能会报错：fatal error: features2d/test/test_detectors_regression.impl.hpp: No such file or directory 按照内容，将opencv-4.1.1/modules/下的features2d文件夹复制到build文件夹下即可。 移植opencv总体流程1.封装函数 需求的操作系统环境下，只允许int char等基本类型的数据类型，因此需要将opencv库中定义的类型（如Mat）做一个转换。函数的输入不再是Mat而是转化成unsigned char和int。 也就是需要在每个opencv函数外面套一层壳，先将unsigned char和int 转为Mat CPoint等输入opencv函数，返回值再转回unsigned char和int作为移植函数的返回值，即可。 2.生成.so动态链接库 编译写好的移植函数生成.so文件： g++ -fpic -shared -o target.so source.cpp `pkg-config --cflags --libs opencv4` -std=c++11 一步到位，直接生成.so文件 3.在测试文件中调用so文件测试功能 void * LdSoHandle=dlopen(&quot;./target.so&quot;, RTLD_NOW|RTLD_GLOBAL); 4.编译测试文件生成可执行文件 g++ -std=c++11 main.cpp -o mai `pkg-config --cflags --libs opencv4` -ldl // -ldl一定要加上 opencv图像类型参数的值 类型 int值 elemSize() CV_8UC1 0 1 CV_8UC2 8 2 CV_8UC3 16 3 CV_32FC1 5 4 CV_32FC2 13 8 CV_32FC3 21 12 CV_16FC1 7 2 CV_16FC2 15 4 CV_16FC3 23 6","categories":[{"name":"杂记","slug":"杂记","permalink":"https://www.hanhan0223.cn/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://www.hanhan0223.cn/tags/opencv/"},{"name":"环境","slug":"环境","permalink":"https://www.hanhan0223.cn/tags/%E7%8E%AF%E5%A2%83/"}]},{"title":"PyQt5狗都不用:阴阳师挂机软件OnHook","slug":"PyQt5狗都不用-阴阳师挂机软件OnHook","date":"2021-08-11T15:02:25.000Z","updated":"2022-01-10T01:10:11.307Z","comments":true,"path":"应用/PyQt5狗都不用-阴阳师挂机软件OnHook/","link":"","permalink":"https://www.hanhan0223.cn/%E5%BA%94%E7%94%A8/PyQt5%E7%8B%97%E9%83%BD%E4%B8%8D%E7%94%A8-%E9%98%B4%E9%98%B3%E5%B8%88%E6%8C%82%E6%9C%BA%E8%BD%AF%E4%BB%B6OnHook/","excerpt":"阴阳师玩家占比最大的行为就是刷魂土了，但作为万年老咸鱼，单刷得12体，500樱饼完全挂不了多少局自动。而手动挂……既然是重复操作，就有办法用自动化脚本来代替，于是想到了最简单的模拟鼠标事件来实现。 源码（包含2.0的GUI程序和单独的挂机python脚本）：Github 百度云：OnHook 提取码：mc13 脚本很简单的思路——每一轮只需要两次移动和点击事件，识别到开始界面第一次移动并点击开始按钮，识别到结束界面第二次移动点击奖励界面退出去，然后循环。 为了怕被检测封号，需要对这样机械的行为进行一定伪装：比如一次点击事件的点击次数随机1-3次；每次点击的间隔在0.15-0.3s之间随机；每次移动的时间在0.05-0.25s随机；每次点击的像素点坐标在识别到的点击区域中随机等等。不知道有多大用，感觉是跟我个人手动挂的习惯比较相符的== python现成的pyautogui库： click(x, y) 函数模拟点击","text":"阴阳师玩家占比最大的行为就是刷魂土了，但作为万年老咸鱼，单刷得12体，500樱饼完全挂不了多少局自动。而手动挂……既然是重复操作，就有办法用自动化脚本来代替，于是想到了最简单的模拟鼠标事件来实现。 源码（包含2.0的GUI程序和单独的挂机python脚本）：Github 百度云：OnHook 提取码：mc13 脚本很简单的思路——每一轮只需要两次移动和点击事件，识别到开始界面第一次移动并点击开始按钮，识别到结束界面第二次移动点击奖励界面退出去，然后循环。 为了怕被检测封号，需要对这样机械的行为进行一定伪装：比如一次点击事件的点击次数随机1-3次；每次点击的间隔在0.15-0.3s之间随机；每次移动的时间在0.05-0.25s随机；每次点击的像素点坐标在识别到的点击区域中随机等等。不知道有多大用，感觉是跟我个人手动挂的习惯比较相符的== python现成的pyautogui库： click(x, y) 函数模拟点击 move(x, y) 函数模拟移动 locateOnScreen(image_path, confidence=0.8) 函数获取指定png图片在当前屏幕状态下的左上角坐标和宽高（这里值得一提的是这个函数默认100%相同才识别，有点苛刻，需要修改参数confidence=0.8差不多。但是这个参数的使用是需要调用cv2这个库的，python的依赖属实==顺带吐槽一下，这个库能一下让后面封装的exe应用程序的大小扩大一倍，pyinstaller出来的exe实在太大了）。 整体代码结构，如果把一整个放到while里，按照顺序死循环识别图片，会导致响应的不够及时。而为每一类图片的识别开一个线程又太奢侈了，于是最终选择了协程——又称为微线程，它是实现多任务的另一种方式，只不过是比线程更小的执行单元（操作系统为了程序运行的高效性，每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作，所以线程的切换非常耗性能。但是协程的切换只是单纯地操作CPU的上下文，一秒钟切换上百万次都不会卡死）。 同样的，python有封装好的非常好用的三方库gevent： spawn(func, info) 函数将生成一个协程并绑定func函数，可带输入信息； 将所有协程加入一个list中，通过 joinall(list) 将存储所有协程的矩阵加入协程池，并开始执行所有协程，当所有协程执行完后返回； sleep(time) 将立即休眠当前线程指定时间。 最后就是组装了。将通过pyautogui库实现的识别指定位置并模拟点击行为封装成函数，在spawn中导入，输入为每一类的图片路径即可实现脚本功能。因为这个函数中写有while(True)，因此每个协程都不会主动停止，需等待外部指令中断运行。 也不知道是不是还没过完以前做上位机时的瘾，，每次写个脚本都想封装成exe配个GUI界面……而我只会qt……PyQt5的封装实在太大了，用了各种方法也没能给它压缩下去==想学一下C#了…… version 1.0 经典老界面，我这审美没救了。 P1：可以选择挂机方案，输入挂机轮数（不输入就是无限挂），主窗口显示每次鼠标行为的信息，停止后返回总挂机轮数和用时。 P2：设置挂机方案，双击编辑方案名和选择该方案所需识别的截图。 P3：截图功能，仿QQ。（这里学到了PyQt一个很重要的函数**paintEvent( )**，超级有用，是实现动态效果的好帮手，帮助实现了2.0版本中不少特效） 这软件单独一个窗口，用起来不方便，也不好看，功能还四不像，跟个缝合怪似的，做完就被我放弃了。。 我老想让一个软件的功能尽可能完善，所以每次能想到的可能会用到的都加进去，就很冗余。。 于是立马着手2.0版本👇 version2.0 嗯，主界面如上图所示，挂在客户端的左上角，面积很小，然后改了改UI，看上去还行哈哈。 设计的灵感来自于炉石的HDT插件（看胜率那个），也是悬挂在炉石界面的顶部，看上去轻便美观，一目了然。 功能介绍： 1.第二块 用于显示挂机成功的轮数，简洁明了~停止后再次开始就会重新计数。 2.第三块 是控制开始结束的按钮，主要绑定了三个事件：1.按钮图标的变化；2.挂机线程的启动/停止；3.时间统计框的弹出/落下。 很简单，每次点击判断状态然后修改图标至相应状态 即可； 这里要注意，挂机脚本的函数内是死循环！也就是说当协程被执行，GUI界面会处于假死状态，无法进行任何的UI交互。因此，使用QThread分出一个子线程用于控制挂机任务，将挂机任务的函数内容重写至QThread的run( ) 函数内即可。这里还要注意，中止时不仅需要杀死这个子线程，同时也需要杀死已加入协程池的所有协程。否则鼠标事件依旧会执行。 这个就是纯UI的设计了，使用了github上的方案pyqt5Custom.Toast类👉pyqt5Custom。 首先是一个水平布局，包含一个icon图标、文本Label和关闭按钮，设置了qss样式（黑色半透明，圆角，按钮default、press、hover等不同样式）。其次是动态升起和落下的特效，这里用到了上述的paintEvent( ) 事件。 这个函数不能被直接调用，而是被动触发的，触发条件为——当窗口需要被重绘时（包含第一次显示）（这里又关联了另一个pyqt5内置函数：update( ) 用于发送窗口绘制事件）。那么动态原理就简单了： 通过在父子类中相互调用彼此的update函数实现循环，不断触发paintEvent，在其中使用setGeometry函数不断的调整这个框的显示位置直至达到预期的显示位置。 控制窗体移动的速度变化：采用先快后慢的变化曲线，在视觉感官上会比较自然舒服。因此选用了在0~1之间呈现此曲线的 y = 1 - (1-x) ^ 4 函数。设置参数speed控制速度快慢，计算每次重绘窗体和开始移动时的时间戳之差t，用 speed * t 作为x的输入，那么随着时间的变化，y的值会逐渐接近1直至达到。最后只需要将：原坐标 +/- (y * 移动距离) 这一数据作为setGeometry的输入，就可以实现移动效果了。 3.第一块 用于打开设置选项，如上图所示。选项中包含挂机方案的选择、创建桌面快捷方式和关闭程序的按钮。 唔，弹出收回的动态效果是对上述Toast类的修改，修改了内部的布局内容和动态弹出的方向。另外在收回时的速度曲线我认为是应该跟上述的 y = 1 - (1-x) ^ 4 关于y=x对称的，即先慢后快，因此修改了曲线函数为 y = x ^ 3。 而GUI界面中所有按钮包括方案的分段按钮组的特效都是在paintEvent( ) 这个函数的基础上来实现的。这个函数真的非常非常的重要！ 设置选项里的按钮们的颜色、背景颜色和动态效果等其实我也没想到什么更好的方案，总觉得怪怪的，但又还行。。就先这样了。 PyQt5这个库我暂时是不想再用了。。因为封装的应用程序实在是太大了。。。好蠢，而且启动速度也很慢……接下来要学C#和C++了，正好也是实验室主用的编程语言~ 不过这个GUI界面我还是比较满意的哈哈哈~就酱 something今天是2022.1.9，从我加入实验室以来已经快一学期了，确实干上了C#相关的活。。。但感觉自定义UI还是Qt香就是说QAQ","categories":[{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"https://www.hanhan0223.cn/tags/PyQt5/"},{"name":"小软件","slug":"小软件","permalink":"https://www.hanhan0223.cn/tags/%E5%B0%8F%E8%BD%AF%E4%BB%B6/"},{"name":"脚本","slug":"脚本","permalink":"https://www.hanhan0223.cn/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"web端小作品","slug":"web端小作品","date":"2020-09-10T02:32:10.000Z","updated":"2022-01-10T06:55:41.426Z","comments":true,"path":"应用/web端小作品/","link":"","permalink":"https://www.hanhan0223.cn/%E5%BA%94%E7%94%A8/web%E7%AB%AF%E5%B0%8F%E4%BD%9C%E5%93%81/","excerpt":"","text":"一些H5的小玩意儿，自己写的或是网上漂的。 金翰林6栋洗衣机使用情况LaundryStatus 聚光灯特效SpotLight 合成大西瓜魔改Daxigua","categories":[{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hanhan0223.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"ID卡与IC卡原理","slug":"ID卡与IC卡原理","date":"2020-08-14T15:27:28.000Z","updated":"2022-01-10T01:10:11.130Z","comments":true,"path":"原理/ID卡与IC卡原理/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/ID%E5%8D%A1%E4%B8%8EIC%E5%8D%A1%E5%8E%9F%E7%90%86/","excerpt":"ID卡（非接触卡）的读卡原理1.简单描述ID卡全称为身份识别卡（Identification Card）,是一种不可写入的感应卡,含固定的编号,主要类型有台湾SYRIS的EM格式，美国HID,TI,MOTOROLA等。 在出厂时，厂家会将ID号写死在芯片的内部，是不允许进行二次修改的。国内常见的型号有EM4100和EM4102。 有别于IC卡这种高频（13.56MHz）、可加密的存储卡，ID卡属于低频（125KHz）的只读卡。 2.读卡流程1.读卡器采用射频识别技术（RFID），持续发射特定频率的射频信号 2.当ID卡进入读卡器工作范围时，将产生感应电流，将自身芯片内的编码信息通过线圈发送出去","text":"ID卡（非接触卡）的读卡原理1.简单描述ID卡全称为身份识别卡（Identification Card）,是一种不可写入的感应卡,含固定的编号,主要类型有台湾SYRIS的EM格式，美国HID,TI,MOTOROLA等。 在出厂时，厂家会将ID号写死在芯片的内部，是不允许进行二次修改的。国内常见的型号有EM4100和EM4102。 有别于IC卡这种高频（13.56MHz）、可加密的存储卡，ID卡属于低频（125KHz）的只读卡。 2.读卡流程1.读卡器采用射频识别技术（RFID），持续发射特定频率的射频信号 2.当ID卡进入读卡器工作范围时，将产生感应电流，将自身芯片内的编码信息通过线圈发送出去 3.读卡器接收到从ID卡发送来的调制信号，经过解调后，得到ID卡的编码信息 3.工作原理1.读卡器发送射频信号：推挽式功放电路（放大）+LC谐振电路（选频） + 2.ID卡返回编码信息：负载调制 关于负载调制： 通常使用电阻负载调制，原理图如下： 当芯片工作时，会产生由内部存储的编码信息的数据流（即0和1，也就是高低电平），数据流控制开关s的变化，从而改变右端负载的大小。当数据为1时，s接通，负载变小，品质因数会降低，谐振回路两端电压降低；数据为0时同理。线圈右端的电压变化，通过线圈电感耦合传递给读写器，最终改变读写器两端电压的振幅变化，产生包络。如下图所示： 图中a为原本信号，b为ID卡线圈的电压，c为读卡器收到的未解调的电压信号，而红框中包络即为解调后的信号。 整体过程：当ID卡靠近读卡器，谐振将能量感应到了卡内线圈上，产生电流并对电容进行充电，于是产生了使芯片工作的电源电压。芯片输出存储的数据流，通过负载调制的方式将数据发送给了读卡器。 3.读卡器解调信号获取编码：包络检波+滤波整形 上文中提到读卡器接收到的载波的包络即为我们想要的数据，这些数据的编码方式为曼彻斯特码。要获取这些数据就需要包络检波。 上图为包络检波部分电路，获取到载波的包络部分，但是还需要进行滤波整形获得平滑的直流电压（曼彻斯特码），如下图： 以上电路就是读卡器和ID卡内所需的一些电路。在最后获取到ID卡相应卡号的曼彻斯特码后，只需要对其进行解码即可获得ID卡卡号，并和后台数据对比判断能否通过验证~ 4.曼彻斯特码常见编码方式分为以下几种： 1.NRZ编码（不归零编码）：数据1和0分别用高低电平表示，当一位数据传输完后电平信号不归零。 2.BiPhase编码（双相编码）：每当一位数据传输后，电平跳变一次。 3.曼彻斯特编码：利用信号边沿来表示0和1，并且跳变发生在位帧中间，比如上升沿表示1，下降沿0。 曼彻斯特码的编码 设数据传输的波特率为f，则一个位的时长为1/f，半个位帧的时长为T = 1/2f。 设两个函数RisingEdge(T)和FallingEdge(T)，执行过程如下： RisingEdge(T)：输出低电平，等待T，输出高电平，等待T，返回； FallingEdge(T)：输出高电平，等待T，输出低电平，等待T，返回。 编码的流程如下： 曼彻斯特码的解码 1.获取数据流的波特率 2.同步数据流的时钟信号（区分位帧边沿和半位帧边沿） 3.根据编码原理进行解码即可 5.常见ID卡型号的卡号数据格式（EM4100）EM4100可存储64bits数据，可读不可写，它的数据格式如下： **1.**第一行，是9个“1”，这是EM4100固定的格式 **2.**D00D03，就是第一个ID号，P0代表的是第一行的偶校验（例：0010_1/0001_1/0110_0）当D00D03中0的个数不为偶数时，偶校验置1。P0-P9均为每行前四位的偶校验，ID号共10位 **3.**PC0~PC3为每列（P0-P9）的偶校验，（例：0000000110_0） 4.举个栗子：卡号为06001259E3，转换可得111111111 00000 01100 00000 00000 00011 00101 01010 10010 11101 00110 01000（这一串64位就是曼彻斯特码解码后得到的数据） **5.**在编写程序判断卡号时，应舍弃前63位数据，只取第一次64位码中的停止位0作为开头，以0111111111作为校验开头，判断第二次64位数据中的前63位数据是否符合。同理，判断完后本次的第64位停止位0作为开头再次判断，重复三次，确认卡号正确。 **6.**卡号06001259E3，其中的第一位0为版本号，第二位6为客户号，后面8位为ID号。 7.若卡面有标注卡号，格式一般为0001202659 (18,23011)。分别为ABA码和wiegand26码。ABA码由8位ID号转换成10进制可得，共10位，少位在前补0。wiegand26码这组数据分别为8位ID号的倒数56位和倒数后四位转换成十进制组成。 关于IC卡相比于ID卡，IC卡在目前的应用更加的广泛1、安全性 IC卡的安全性远大于ID卡，ID卡内的卡号读取无任何权限,易于仿制。IC卡内所记录数据的读取，写入均需相应的密码认证,甚至卡片内每个区均有不同的密码保护，全面保护数据安全，IC卡写数据的密码与读出数据的密码可设为不同，提供了良好分级管理方式，确保系统安全。 2、可记录性 ID卡不可写入数据,其记录内容(卡号)只可由芯片生产厂一次性写入，开发商只可读出卡号加以利用，无法根据系统的实际需要制订新的号码管理制度。IC卡不仅可由授权用户读出大量数据，而且亦可由授权用户写入大量数据(如新的卡号，用户的权限，用户资料等)，IC卡所记录内容可反复擦写。 3、存储容量 ID卡仅仅记录卡号；而IC卡(比如Philips mifare1卡)可以记录约1000个字符的内容 4、脱机与联网运行 由于ID卡卡内无内容，故其卡片持有者的权限，系统功能操作要完全依赖于计算机网络平台数据库的支持。 而IC卡本身已记录了大量用户相关内容(卡号，用户资料，权限，消费余额等大量信息)，完全可以脱离计算机平台运行,实现联网与脱机自动转换的运行方式，能够达到大范围使用，少布线的需求。 5、一卡通扩展应用 ID卡由于无记录,无分区,只能依赖网络软件来处理各子系统的信息,这就大大增加对网络的依赖；如果在ID卡系统完成后,用户欲增加功能点，则需要另外布线,这不仅增加了工程施工难度,而且增加了不必要的投资.所以说,使用ID卡来做系统,难以进行系统扩展,难以实现真正的一卡通。 而IC卡存储区自身分为16个分区，每个分区有不同的密码,具有多个子系统独立管理功能，如第一分区实现门禁，第二分区实现消费,第三分区实现员工考勤等等。充分实现一卡通的目的,并且可以做到完全模块化设计，用户即使要增加功能点，也无需再布线,只需增加硬件和软件模块，这便于IC卡系统以后的随时升级扩展,实现平稳升级,减少重复投资。 6、智能化系统的维护和运行 比如：电脑发行了一张新的用户ID卡,就必须通过ID卡系统的网络,用人工方式将所有ID卡号一个个下载到各ID卡读卡控制器中，否则ID卡被作为无效卡而不能使用;若要更改用户权限，则需在每个ID卡控制器上输入有权限的ID卡号。 又比如：在系统投入使用后经常要新增ID卡,则每新增一张卡或修改了某一张卡片的权限,就必需在该卡可用的所有控制器上输入该卡片号码，这就增加了工作量 关于手机NFC功能苹果手机仅支持apple pay，门禁、公交等功能并不支持。小米还是香嗷。 在b站看到稚晖大佬做了一个可以存储多张ic卡信息的小卡片，开源了👉L-ink_Card 以后有机会想自己实现一哈","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"电子","slug":"电子","permalink":"https://www.hanhan0223.cn/tags/%E7%94%B5%E5%AD%90/"}]},{"title":"关于url编码","slug":"关于url编码","date":"2020-05-20T14:20:46.000Z","updated":"2022-01-10T01:10:11.388Z","comments":true,"path":"原理/关于url编码/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/%E5%85%B3%E4%BA%8Eurl%E7%BC%96%E7%A0%81/","excerpt":"为什么需要URL编码1.URL 只能使用 ASCII 字符集来通过因特网进行发送。也就是说URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。这意味着 如果URL中有汉字，就必须编码后使用。但问题在于，标准的国际组织并没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这会导致”URL编码”成为了一个混乱的领域。 2.对于get传参的网页来说，采取的是如下方式 ( ? key = value ) 问题在于，若是传的参数中包含？和=怎么办，就冲突了，所以需要编码以区分 http://www.biquge.tv/modules/article/search.php?searchkey=xxx 如何进行URL编码Url编码通常也被称为百分号编码（percent-encoding），编码方式非常简单。 使用%百分号加上两位的字符——0123456789ABCDEF——代表一个字节的十六进制形式。","text":"为什么需要URL编码1.URL 只能使用 ASCII 字符集来通过因特网进行发送。也就是说URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。这意味着 如果URL中有汉字，就必须编码后使用。但问题在于，标准的国际组织并没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这会导致”URL编码”成为了一个混乱的领域。 2.对于get传参的网页来说，采取的是如下方式 ( ? key = value ) 问题在于，若是传的参数中包含？和=怎么办，就冲突了，所以需要编码以区分 http://www.biquge.tv/modules/article/search.php?searchkey=xxx 如何进行URL编码Url编码通常也被称为百分号编码（percent-encoding），编码方式非常简单。 使用%百分号加上两位的字符——0123456789ABCDEF——代表一个字节的十六进制形式。 对于ASCII字符，字母a 在ASCII码中对应的字节是0x61，那么Url编码之后得到的就是%61，字母abc， url编码后得到的就是%61%62%63。 对于非ASCII字符，在无BOM编码格式中有UTF-8和GBK两种。 1.”中文”使用UTF-8字符集得到的字节为0xE4 0xB8 0xAD 0xE6 0x96 0x87，经过Url编码之后得到”%E4%B8%AD%E6%96%87”。 2.“中文”使用GBK编码得到 %D6%D0%CE%C4。 注意一定要先进行编码再向服务器提交，这样可以保证只使用了固定的一种编码方式。 python中的URL编码与解码封装成以下库： 编码和解码的调用： 小说爬取爬小说的脚本写的时候没碰到什么别的问题，就是一个编码的问题，之前不了解，所以写了这篇文章码一下。 在用爬虫向网页提交搜索信息（小说名字）的时候： http://www.biquge.tv/modules/article/search.php?searchkey=%bd%a3%c0%b4 需要用到URL编码来提交（因为我爬的那个网站用的是get方式提交信息，并且是GBK编码）","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"加密与编码","slug":"加密与编码","permalink":"https://www.hanhan0223.cn/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%BC%96%E7%A0%81/"}]},{"title":"关于RSA加密算法","slug":"关于RSA加密算法","date":"2020-05-16T14:27:37.000Z","updated":"2022-01-10T01:10:11.383Z","comments":true,"path":"原理/关于RSA加密算法/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/%E5%85%B3%E4%BA%8ERSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/","excerpt":"RSA是目前使用最广泛的公钥密码体制之一。 RSA产生公私钥对1.随机选取两个相近但不相等的质数p和q（越大越难破解） 取p=11，q=13，n = p * q = 143，n即为密钥长度，143二进制为10001111，密钥为8位。实际应用中，一般为1024位。 2.计算n的欧拉函数z z = (p-1)(q-1) = 120 3.随机选择一个整数e，作为公钥中用来加密的数字 条件1 &lt; e &lt; z，且e与z互质。假设随机选择e = 7（实际中常选择为65537）","text":"RSA是目前使用最广泛的公钥密码体制之一。 RSA产生公私钥对1.随机选取两个相近但不相等的质数p和q（越大越难破解） 取p=11，q=13，n = p * q = 143，n即为密钥长度，143二进制为10001111，密钥为8位。实际应用中，一般为1024位。 2.计算n的欧拉函数z z = (p-1)(q-1) = 120 3.随机选择一个整数e，作为公钥中用来加密的数字 条件1 &lt; e &lt; z，且e与z互质。假设随机选择e = 7（实际中常选择为65537） 4.计算e对于z的模反元素d，作为密钥中用来解密的数字 模反元素指存在一个整数d，使得e * d mod z = 1。带入可得d = 103 5.将n和e封装成公钥（143，7），n和d封装成密钥（143，103） 题外话：关于m^e mod n的手动计算方法利用 (a×b) mod m = ((a mod m) × (b mod m)) mod m 这个公式 设三个变量a，b，c，对于m^e mod n，令a = e,b = m, c = 1 然后重复以下步骤： 1.判断a是奇数，进第2步；偶数进第3步 2.a = a - 1, c = (c*b) mod n,回到第1步 3.a = a / 2, b = (b*b) mod n,回到第1步 直到a = 0, c 就是最终结果 RSA的加密和解密加密：c = m^e mod n 解密：m = c^d mod n 首先对明文进行比特串分组，且保证每个分组对应的十进制数小于n，然后对每个分组进行一次加密，所有分组的密文组成的序列就是最终密文了。 举两个栗子： 1.以数据加密为例： 甲向乙发送机密数据信息m=85，并已知乙的公钥(n,e)=(143,7)，于是可计算出：c = 123甲将c发送至乙，乙利用私钥(n,d)=(143,103)对c进行计算：m = 85则乙得到甲向其要发送的机密数据信息。甲向乙发送信息，甲所拥有的仅仅是乙的公钥。 2.以数字签名为例： 乙要向甲发送信息，并要让甲确信此信息是由乙本人所发出的，于是，乙将能代表自己身份的编码值（如：123），利用私钥(n,d)=(143,103)进行计算，并将结果发送给甲：m = 85甲接受到乙的数字签名后利用乙的公钥(n,e)=(143,7)进行计算，得出代表乙身份的编码：c = 123现甲经过验证已确信信息的发送方为乙。因为只有乙拥有私钥(n,d)，来对代表自己身份的编码123进行计算。在这里，乙向甲发送信息并进行签名，甲所拥有的也仅仅是乙的公钥来验证乙的签名。 RSA实际应用在基于序列号保护的共享软件中应用RSA。 在某一共享软件中，甲想用123为注册名进行软件注册，他现在拥有的仅仅是存在于共享软件程序中的公钥(n,e)=(143,7)。 甲现将123为注册名向乙提出注册申请，乙得知此申请并通过此申请后，便利用所拥有的私钥(n,d)对注册名123进行计算：m = 85 甲得到计算后的结果85（序列号），提供给共享软件的注册程序进行计算：c = 123 然后注册程序将判断计算结果c是否为123（注册名），以决定注册是否通过。 如果甲随意输入一组序列号利用公钥(n,e)进行计算，那他得到的结果将不是123，注册也就失败了。注意，在这里，共享软件的注册程序比较的是注册名，而不是序列号。 如果甲跟踪注册程序得到了他所随意输入的序列号所产生的注册名，将其提供给注册程序，那注册程序也能够通过注册，但他由于没有(n,d)，所以他无法用自己的注册名进行软件注册，也就防止了非法注册机的制作。 将RSA应用于此的目的仅仅是防止非法注册机的制作，在以上描述中，n=143，包括以下Demo中的n(HEX)=963251DC5A9C90D9F203A03C363BA411，以现在的计算机处理速度，能很快地将其因式分解得到相应的p，q，再结合暴露在共享软件注册程序中的e，从而计算出d，那么这个共享软件的保护就完全被破解了。解决的方法是要避免n过短，以及结合MD5等加密算法……","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"加密与编码","slug":"加密与编码","permalink":"https://www.hanhan0223.cn/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%BC%96%E7%A0%81/"}]},{"title":"获取bilibili视频文件和封面","slug":"获取bilibili视频文件和封面","date":"2020-04-30T15:27:07.000Z","updated":"2022-01-10T01:40:44.618Z","comments":true,"path":"应用/获取bilibili视频文件和封面/","link":"","permalink":"https://www.hanhan0223.cn/%E5%BA%94%E7%94%A8/%E8%8E%B7%E5%8F%96bilibili%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E5%92%8C%E5%B0%81%E9%9D%A2/","excerpt":"前两天在阿草微博粉丝群水群的时候，看到有朋友说馋想要一个往期视频的封面，但不知道咋保存~（网上有封面提取的网站） 我一想，应该可以用爬虫去实现嘛，挺有意思的，就尝试着写了一下，链接如下👇 获取b站视频封面 （现在挂在我的云服务器上，但等到过期了就寄了，GitHub Page并不支持php。话说当初学php就是因为在云服务器上建站用的WordPress，想改别人的主题但是看不懂代码才去学的） 三项功能： 输入视频的网址、BV号获取AV号（AV号明面上已经被b站禁了，但后台实际还在）； 输入视频的网址、BV号、AV号获取视频封面； 输入up主的UID获取该up主所有视频的封面，并打包成zip文件下载。 获取封面1.爬取图片的脚本","text":"前两天在阿草微博粉丝群水群的时候，看到有朋友说馋想要一个往期视频的封面，但不知道咋保存~（网上有封面提取的网站） 我一想，应该可以用爬虫去实现嘛，挺有意思的，就尝试着写了一下，链接如下👇 获取b站视频封面 （现在挂在我的云服务器上，但等到过期了就寄了，GitHub Page并不支持php。话说当初学php就是因为在云服务器上建站用的WordPress，想改别人的主题但是看不懂代码才去学的） 三项功能： 输入视频的网址、BV号获取AV号（AV号明面上已经被b站禁了，但后台实际还在）； 输入视频的网址、BV号、AV号获取视频封面； 输入up主的UID获取该up主所有视频的封面，并打包成zip文件下载。 获取封面1.爬取图片的脚本如何找到b站视频的相关信息和封面图片的源网址呢？ 关于封面图最开始学爬虫的朋友们应该都爬过豆瓣top250这个经典案例。 在body里找到img属性，里面的src就是图片的原链接了。但是要注意到一点，这里图片源文件的后缀：webp。这是一种有损压缩格式图片，优势在于网络传输快，但爬取视频封面是为了什么！是为了高清图啊！所以不能这么爬。 在个人主页中，可以通过选取工具定位到img标签，发现src里的也是webp格式图片 打开链接图片很糊而且像素低。那么问题来了，哪里有高清的呢！答案就在视频界面里。 不在body中！因为视频界面并没有显示封面图片！而是在head中！找到属性（itemprop）为image的，发现content中的链接，后缀为jpg格式，这就找对了，打开发现确实是高清图 链接位置找到了，剩下的就简单了~就不多说了。 关于AV号之前b站因为av号名称违规（？）改为了BV号，但是av号并没有完全删除，在b站中搜索视频av号同样能获取视频，这说明av号这项数据依旧保存着，那如何找出该数据呢？在b站的数据接口。 打开解析器network选项，可以看到该视频数据接口的url。archive（档案）后面的内容aid同理可以替换成bvid 可以看到该网址返回的是一串json数据，里面包含了av、bv、投币、收藏、点赞、分享、评论、观看数、这些数据，在这里便可以获取到AV号了，在就脚本中解析该json数据然后提取就可以显示在网页中了。 而个人空间同样拥有数据接口保存了该页所有视频的标题、简介、bv等信息，也可以获取下来，不再赘述。 2.py脚本与php的数据交互py文件如何向php文件传值？ ajax如何获取php文件的传值？php中如何调用py脚本？ 传值其实很简单，，就是打印函数，python 的print和php 的echo。 调用py脚本，用exec函数： $c = exec(&quot;/usr/bin/python GetBilibiliUpCover.py &#123;$func&#125; &#123;$uid&#125; &#123;$bv&#125;&quot;); exec用于执行一个外部程序，主体为执行命令，可以附带参数传递，输出数组和状态返回。因为程序要在服务器里运行，所以输入的就是ubuntu的命令行了，ubuntu怎么运行python脚本就怎么来。 后面的三个是输入参数。在python中通过如下方式获取： sys.argv[1] argv是一个数组，第一位是模块的名称，这里不去管他，从1开始是按序输入的参数，这里输入了三个，就分别用1、2、3来获取就行。 3.前后端数据交互本半吊子表示根本没系统学过前端知识，所以做这一部分的时候异常痛苦，，界面也丑的一言难尽== 用的ajax，但一开始死都进不去succes步，总进error。。 $.ajax(&#123; type : &quot;GET&quot;, url : &quot;getting.php&quot;, data : &#123; &#39;func&#39;:$(&quot;#f1&quot;).val(), &#39;bv&#39;:$(&quot;#av_info&quot;).val() &#125;, dataType : &quot;text&quot;, success : function(msg) &#123; $(&quot;#result&quot;).empty(); document.getElementById(&quot;dynamic_av&quot;).style.display = &quot;&quot;; var data = &#39;&#39;; if (msg != &#39;&#39;)&#123; data = eval(&quot;(&quot;+msg+&quot;)&quot;); &#125; $(&quot;#result_av&quot;).html(&quot;AV号: &quot; + data.av); &#125;, error: function (msg, textStatus) &#123; console.log(msg); &#125; &#125;); 后来发现一开始数据类型用的json，网上说必须要非常标准的json数据才能接收到，我也不明白为什么我在py文件里封装的json数据就不行。。。 后来就改成text，文本用eval转化一下提取出来就解决了。 获取视频文件首先进F12，看一下： 可以看到视频源文件这边并不是mp4的源文件，而是开头带了blob：的链接，是无法访问的（暂时不了解这方面的技术，所以找了个取巧的办法） 点击开发者工具的左上角，切换为手机模拟状态，可以看到： 手机端的src不再是blob了，而是变成了这样一个url，打开即可下载mp4源文件了~舒服！","categories":[{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://www.hanhan0223.cn/tags/%E8%84%9A%E6%9C%AC/"},{"name":"前端","slug":"前端","permalink":"https://www.hanhan0223.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.hanhan0223.cn/tags/python%E7%88%AC%E8%99%AB/"}]},{"title":"第一次笔记本拆机体验","slug":"第一次笔记本拆机体验","date":"2020-04-13T14:38:42.000Z","updated":"2022-01-10T01:10:11.408Z","comments":true,"path":"杂记/第一次笔记本拆机体验/","link":"","permalink":"https://www.hanhan0223.cn/%E6%9D%82%E8%AE%B0/%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%8B%86%E6%9C%BA%E4%BD%93%E9%AA%8C/","excerpt":"小的时候总觉得电脑是个很神奇很牛掰的东西，虽然后来对电脑的构成还有运行原理等有了一个大致的了解，但依旧玄乎中带一点敬仰（奇怪的用词）。前段时间给母亲大人配了一台台式，自己亲自买了各种组件，组装起来后才发现其实真没什么难度。。基本是熟练度和经验的关系了。不过这倒是让我对电脑组成和运行有了更深刻的认识~ 恰巧我的笔记本最近也毛病重重（贼卡），于是在我的一位同学祝大师（sdl，wsl）的帮助下，对电脑运行的CPU占用率、硬盘测速、甜甜圈视频输出、内存延时、模具散热、坏道检测等多项数据进行了测试。发现了唯一的问题在于机械盘坏道有点多（跑了1%就有几十柱坏道，神奇，讲道理坏成这样应该经常会卡死，而我只是运行慢一些。。） 然后开始拆机~清灰，然后取出机械硬盘在台式机进行一些测试。 拆机简录 首先把四周的螺丝拧开~然后掰开后盖。因为后盖四周带有卡扣固定，所以在掀开的过程中需要拿螺丝刀一点一点的撬开。注意到上图中左右两个网格状的梯形，里面有两坨圆形的灰色，这都是灰，因为这两个网格正对电脑的散热风扇，久而久之在散热过程中就积灰了。 最后掀开，如下：","text":"小的时候总觉得电脑是个很神奇很牛掰的东西，虽然后来对电脑的构成还有运行原理等有了一个大致的了解，但依旧玄乎中带一点敬仰（奇怪的用词）。前段时间给母亲大人配了一台台式，自己亲自买了各种组件，组装起来后才发现其实真没什么难度。。基本是熟练度和经验的关系了。不过这倒是让我对电脑组成和运行有了更深刻的认识~ 恰巧我的笔记本最近也毛病重重（贼卡），于是在我的一位同学祝大师（sdl，wsl）的帮助下，对电脑运行的CPU占用率、硬盘测速、甜甜圈视频输出、内存延时、模具散热、坏道检测等多项数据进行了测试。发现了唯一的问题在于机械盘坏道有点多（跑了1%就有几十柱坏道，神奇，讲道理坏成这样应该经常会卡死，而我只是运行慢一些。。） 然后开始拆机~清灰，然后取出机械硬盘在台式机进行一些测试。 拆机简录 首先把四周的螺丝拧开~然后掰开后盖。因为后盖四周带有卡扣固定，所以在掀开的过程中需要拿螺丝刀一点一点的撬开。注意到上图中左右两个网格状的梯形，里面有两坨圆形的灰色，这都是灰，因为这两个网格正对电脑的散热风扇，久而久之在散热过程中就积灰了。 最后掀开，如下： 上图中左右上角是风扇，可以看到积灰很多。风扇上面是散热管，它与风扇之间的缝隙同样是积灰非常严重的地方，需要清理。 中间蓝色是主板，主板上面那块绿色就是内存条，我的是一根8g的（反正也要换硬件，顺便再加个8g内存条？） 右边风扇下面的绿色是固态硬盘（当时配的128g，这次打算换成256g，我c盘就剩12G了，括个容），用作电脑的系统盘存储。 左边风扇下面那块蓝青色板子就是机械硬盘了（配的1T，叠瓦的据说坏的快，在犹豫换1T的机械还是固态，，价格差了五六百，但固态体验要好很多） 机械盘右上角那一小块贴了白色标签的就是无线网卡 右下方那一大块是电池了，图里已经拆了~ 拆下之后对积灰的缝隙，风扇的缝隙进行了清理，顿时感觉舒爽了很多hhhh 问题测试取下机械硬盘，接到我家台式机上，在里面下了个300英雄打了一把人机，发现流畅的一批，，惊了 又接回来进入ubuntu系统，跑了一下pycharm，，还是很流畅 大概是系统问题，，，遇事不决重装系统~ 后续 京东物流是真的快！当晚9点多下单，第二天上午就到了！1TB的SSD硬盘，SATA接口（换机械的），打折799. 然后是数据转移！ 把原来的机械盘和新的固态盘都接到我家台式机上，先格式化好新盘，转gpt分区。我用了DiskGenius的磁盘克隆功能，一键复制分区和数据（大概三个小时左右，我1T基本用满了），然后就搞定啦。 剩下的机械盘格式化了塞家里电脑凑合用着，舒服！ 把固态塞进笔记本，开机，测试了一下软件启动速度，真香！","categories":[{"name":"杂记","slug":"杂记","permalink":"https://www.hanhan0223.cn/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"拆机","slug":"拆机","permalink":"https://www.hanhan0223.cn/tags/%E6%8B%86%E6%9C%BA/"},{"name":"硬件","slug":"硬件","permalink":"https://www.hanhan0223.cn/tags/%E7%A1%AC%E4%BB%B6/"}]},{"title":"PyQt5再尝试:Windows桌面便笺","slug":"PyQt5再尝试-Windows桌面便笺","date":"2020-04-08T14:50:34.000Z","updated":"2022-01-10T01:10:11.177Z","comments":true,"path":"应用/PyQt5再尝试-Windows桌面便笺/","link":"","permalink":"https://www.hanhan0223.cn/%E5%BA%94%E7%94%A8/PyQt5%E5%86%8D%E5%B0%9D%E8%AF%95-Windows%E6%A1%8C%E9%9D%A2%E4%BE%BF%E7%AC%BA/","excerpt":"考研党给自己制定了每日计划去执行，但是市面上的桌面便笺软件都不是很合我胃口，于是花了一个礼拜多点，完成了这款完全按照我自己心意来的桌面便笺，用起来相当舒心、顺手嘿嘿。 国际惯例贴上源代码、以及软件下载链接~ GitHub：memo-master 百度网盘：memo 提取码：61uy Version：1.0 【2020.4.8】先上图~ 主图标选择了我非常喜欢的滑稽表情~ 灯泡是用来展开、隐藏下边菜单栏的开关~ 菜单栏分别是新建一个便笺、设置（字体样式，便笺样式等）以及关于（软件的简单使用tips） 右边就是建的一个个便笺了~","text":"考研党给自己制定了每日计划去执行，但是市面上的桌面便笺软件都不是很合我胃口，于是花了一个礼拜多点，完成了这款完全按照我自己心意来的桌面便笺，用起来相当舒心、顺手嘿嘿。 国际惯例贴上源代码、以及软件下载链接~ GitHub：memo-master 百度网盘：memo 提取码：61uy Version：1.0 【2020.4.8】先上图~ 主图标选择了我非常喜欢的滑稽表情~ 灯泡是用来展开、隐藏下边菜单栏的开关~ 菜单栏分别是新建一个便笺、设置（字体样式，便笺样式等）以及关于（软件的简单使用tips） 右边就是建的一个个便笺了~ 功能简介： 双击可以修改内容（目前无法使用删除键，修改方式为鼠标全选后直接输入文本，待debug） 右边按钮为当日完成情况，初始化为X，点击表示完成√ 删除：拖动单条便笺到主图标滑稽上，松开鼠标即可删除 按~键（ESC下面）即可最小化至托盘 拖动主图标即可拖动整个便笺软件移动 对便笺样式以及内容的修改信息均会保存，在下次启动时直接调用~ 主图标以及各种按钮的图标均可找自己喜欢的图片修改（要求：png图片、背景透明（怎么弄透明百度有教程，可网站上在线生成也可ps自己弄）、将处理好的图片与想改的图标做替换（文件名要相同）） 因为在x64系统下封装，仅适用于x64系统，linux和Windows x32目前不支持~ 关于里面的介绍是之前写的，忘改了，，下版再说吧，懒得重新改 对于下版的一些想法： 1.优化UI、以及界面控制，修复一些按键bug 2.添加时间数据，记录计划的创建、删除时间以及每天完成情况；每日0：00更新所有便笺状态为X 3.添加数据分析功能，生成统计文件。哦甚至一键生成统计图表（？这个好像有点麻烦，，得慢慢来） 4.添加一键换图标功能（仅需上传png图片） 5.想和网站做点联动，但不知道做啥==下版见 就酱~ Version：1.1 【2020.4.24】1.1版本搞定！ 1.优化了设置和关于界面的UI 2.添加了主图标右键可以打开菜单栏操作功能 3.新增部分设置选项（置顶功能设置、勾选重启以创建桌面快捷方式、边缘自动隐藏功能） 4.完善了每个便笺个体的信息保存，软件在下一天启动时所有便笺状态归于未完成 5.删除了任务栏图标，只保留托盘图标了 6.更新了数据统计功能，从整体和个体角度分析完成情况 7.新增简单的一键换肤功能（不提倡，建议ps手动修图手动在img文件夹下替换） 8.关于与个人网站的联动，会做一个内测版本，将我每日的学习进度展示在我的个人网站上~暂时不打算封装起来 这个小项目就告一段落了~~ 接下来的安排基本以考研为主了，以算法题为主要练习对象，偶尔有需求再写点脚本什么的~ Version：1.2 【2020.6.6】1.新增了倒计时功能，置于电脑屏幕正上方，右键为设置（内容和结束时间）、隐藏。隐藏后可在菜单栏打开。 2.新增了版本检测以及自动更新功能（有一点小bug没解决，点更新会跳cmd框并且更新时鼠标操作其他地方进度条的显示会卡死，但是不影响更新的）。更新后再次点击图标重启（重启才会删除旧版本，我没封装成正式软件，也没解决父子进程独立的问题，用的更新方法比较简单~） 3.修复了个别显示以及数据统计的小bug~ 唔，越来越感觉这软件粗制滥造了hhhh，等我有空研究一下软件构造方面的知识之后再重构一遍~ Version：2.0【2022.1.9】没想到，这小玩意儿最后居然被我拿来当毕设了。。就挺水的== 当时为了凑毕设字数就重构了一遍代码（UI与逻辑分离之类的），但是时间比较紧，也没重构完。。所以也就没更新 现在把博客从云服务器迁到github上，才想起来这回事儿。。有空搞搞？（十有八九是没下文了）","categories":[{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"https://www.hanhan0223.cn/tags/PyQt5/"},{"name":"小软件","slug":"小软件","permalink":"https://www.hanhan0223.cn/tags/%E5%B0%8F%E8%BD%AF%E4%BB%B6/"}]},{"title":"PyQt5初尝试:Unicode转换器","slug":"PyQt5初尝试-Unicode转换器","date":"2020-03-07T14:46:57.000Z","updated":"2022-01-10T01:10:11.231Z","comments":true,"path":"应用/PyQt5初尝试-Unicode转换器/","link":"","permalink":"https://www.hanhan0223.cn/%E5%BA%94%E7%94%A8/PyQt5%E5%88%9D%E5%B0%9D%E8%AF%95-Unicode%E8%BD%AC%E6%8D%A2%E5%99%A8/","excerpt":"Unicode转换器Version 1.1.0 【2020.3.7】最近玩阴阳师的时候接触到一位大哥写的御魂hub网站，里面通过对json文件的解析来实现了大量御魂配置的计算，省去了手动配置的无限痛苦！！！超级好用！！！ ❤❤❤ 另外有个软件可以从阴阳师桌面版中提取出账号中所有的御魂信息并集合成一个json文件，恰巧最近几天尝试了简单的python爬虫，在爬取动态信息时同样涉及到了json~~这让我对json产生了兴趣。于是今天下午尝试着解析Unicode为字符串，集成在小软件里。 python也只是刚入门，所以目前只实现了这一点点小功能。效果图如下👇 源代码我上传到GitHub了非常简单的两个小文件 戳这里去star吧👇https://github.com/shen962806862/Unicode-Chinese 另外我也生成了单独的exe文件，可以直接使用 👇https://pan.baidu.com/s/1G1BLW82elUwAee7DSpzQqA 提取码：9qfw","text":"Unicode转换器Version 1.1.0 【2020.3.7】最近玩阴阳师的时候接触到一位大哥写的御魂hub网站，里面通过对json文件的解析来实现了大量御魂配置的计算，省去了手动配置的无限痛苦！！！超级好用！！！ ❤❤❤ 另外有个软件可以从阴阳师桌面版中提取出账号中所有的御魂信息并集合成一个json文件，恰巧最近几天尝试了简单的python爬虫，在爬取动态信息时同样涉及到了json~~这让我对json产生了兴趣。于是今天下午尝试着解析Unicode为字符串，集成在小软件里。 python也只是刚入门，所以目前只实现了这一点点小功能。效果图如下👇 源代码我上传到GitHub了非常简单的两个小文件 戳这里去star吧👇https://github.com/shen962806862/Unicode-Chinese 另外我也生成了单独的exe文件，可以直接使用 👇https://pan.baidu.com/s/1G1BLW82elUwAee7DSpzQqA 提取码：9qfw 接下来会有2.0版本，打算尝试实现txt文件与json文件的相互转换√ Version 2.0.0 【2020.3.8】弄了一晚上！更新更新！船新版本！ 新增功能： 1.实现了Json文件与txt文件的相互转换，可以快速阅读json文件中的信息了 2.当你添加一个文件后，打开添加文件夹选项，可以自动锁定到输入文件的地址了 2.5.转换生成的文件名与输入文件相同 3.优化了UI界面，实现了窗口自适应 4.优化了数据窗口，滚动条可以自动滑至文本末了 源码和软件链接依旧同上，里面存了所有更新版本的内容~ 大致搞定了第一个python制作小软件了接下来的话打算抽空做一个桌面便笺了敬请期待","categories":[{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"https://www.hanhan0223.cn/tags/PyQt5/"},{"name":"小软件","slug":"小软件","permalink":"https://www.hanhan0223.cn/tags/%E5%B0%8F%E8%BD%AF%E4%BB%B6/"},{"name":"加密与编码","slug":"加密与编码","permalink":"https://www.hanhan0223.cn/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%BC%96%E7%A0%81/"}]}],"categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"},{"name":"杂记","slug":"杂记","permalink":"https://www.hanhan0223.cn/categories/%E6%9D%82%E8%AE%B0/"},{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://www.hanhan0223.cn/tags/opencv/"},{"name":"图像","slug":"图像","permalink":"https://www.hanhan0223.cn/tags/%E5%9B%BE%E5%83%8F/"},{"name":"环境","slug":"环境","permalink":"https://www.hanhan0223.cn/tags/%E7%8E%AF%E5%A2%83/"},{"name":"PyQt5","slug":"PyQt5","permalink":"https://www.hanhan0223.cn/tags/PyQt5/"},{"name":"小软件","slug":"小软件","permalink":"https://www.hanhan0223.cn/tags/%E5%B0%8F%E8%BD%AF%E4%BB%B6/"},{"name":"脚本","slug":"脚本","permalink":"https://www.hanhan0223.cn/tags/%E8%84%9A%E6%9C%AC/"},{"name":"前端","slug":"前端","permalink":"https://www.hanhan0223.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"电子","slug":"电子","permalink":"https://www.hanhan0223.cn/tags/%E7%94%B5%E5%AD%90/"},{"name":"加密与编码","slug":"加密与编码","permalink":"https://www.hanhan0223.cn/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%BC%96%E7%A0%81/"},{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.hanhan0223.cn/tags/python%E7%88%AC%E8%99%AB/"},{"name":"拆机","slug":"拆机","permalink":"https://www.hanhan0223.cn/tags/%E6%8B%86%E6%9C%BA/"},{"name":"硬件","slug":"硬件","permalink":"https://www.hanhan0223.cn/tags/%E7%A1%AC%E4%BB%B6/"}]}