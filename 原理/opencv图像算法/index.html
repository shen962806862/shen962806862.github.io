<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>opencv图像算法 | 小涵的米奇妙妙屋</title><meta name="keywords" content="opencv,图像"><meta name="author" content="Szh"><meta name="copyright" content="Szh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="图像低通滤波邻域滤波">
<meta property="og:type" content="article">
<meta property="og:title" content="opencv图像算法">
<meta property="og:url" content="https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="小涵的米奇妙妙屋">
<meta property="og:description" content="图像低通滤波邻域滤波">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/2.jpg">
<meta property="article:published_time" content="2021-12-23T11:36:24.000Z">
<meta property="article:modified_time" content="2022-07-18T09:08:36.904Z">
<meta property="article:author" content="Szh">
<meta property="article:tag" content="opencv">
<meta property="article:tag" content="图像">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/2.jpg"><link rel="shortcut icon" href="/img/Sign.ico"><link rel="canonical" href="https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a8ed5b37dd0aaae924c52eb382109c5d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'opencv图像算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-18 17:08:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/2.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小涵的米奇妙妙屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">opencv图像算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-23T11:36:24.000Z" title="发表于 2021-12-23 19:36:24">2021-12-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-18T09:08:36.904Z" title="更新于 2022-07-18 17:08:36">2022-07-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8E%9F%E7%90%86/">原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.5k</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="opencv图像算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h1><h2 id="低通滤波"><a href="#低通滤波" class="headerlink" title="低通滤波"></a>低通滤波</h2><h3 id="邻域滤波"><a href="#邻域滤波" class="headerlink" title="邻域滤波"></a>邻域滤波</h3><p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/v2-14d8e1ccf33a81b447d0faf8566bb7ef_r-16402595643921.jpg" alt="preview"></p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211209161017369-16402595643922.png" alt="邻域计算公式"></p>
<span id="more"></span>

<h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p>图像的中值滤波是一种非线性图像处理方法,是统计排序滤波器的一种典型应用。中值滤波是通过<strong>对邻域内像素按灰度排序的结果</strong>决定<strong>中心像素</strong>的灰度。具体的操作过程如下：<font color="red">用一个奇数点的移动窗口，将窗口中心点的值用窗口内各点的中值代替。</font>假设窗口内有5个点，其值为1,2,3,4和5，那么此窗口内各点的中值即为3，也就是用3来代替中心点的像素值。</p>
<p>中值滤波对于滤除<strong>脉冲干扰及图像扫描噪声</strong>最为有效，还可以克服线性滤波器（如领域简单平滑滤波）带来的图像细节模糊。</p>
<p>数字图像存在冗余信息，具体分为六大冗余：空间冗余、时间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余。其中第一个空间冗余就可以很好的解释中值滤波的作用。空间冗余指的是：图像内部<strong>相邻像素之间存在较强的相关性而造成的冗余</strong>。简单来说就是，同一景物表面上采样点的颜色之间通常存在着空间相关性，相邻各点的取值往往相近或者相同，这就是空间冗余。而脉冲噪声通常是在一个邻域内有一个点或多个点的灰度值很高或很低，这就与周围像素存在较大差异，因此中值滤波能很好的去除这种噪声。</p>
<p>需要注意的是，中值滤波的<strong>窗口形状和尺寸</strong>对滤波效果影响很大，不同的图像内容和不同的应用要求，往往采用不同的窗口形状和尺寸。常用的中值滤波窗口有线状、方形、圆形、十字形以及圆环形等等。窗口尺寸一般先用3x3,再取5x5逐渐增大，直到滤波效果满意为止。就一般经验来讲，对于有缓变的较长轮廓线物体的图像，采用方形或圆形窗口为宜。对于包含有尖顶物体的图像，用十字形窗口，而窗口大小则以不超过图像中最小有效物体的尺寸为宜。如果图像中点、线、尖角细节较多（感觉就是邻域灰度值变化较大），则不宜采用中值滤波。</p>
<h3 id="自适应中值滤波"><a href="#自适应中值滤波" class="headerlink" title="自适应中值滤波"></a>自适应中值滤波</h3><p>上面提到常规的中值滤波器，在噪声的<strong>密度不是很大</strong>的情况下，效果不错。但是密度较高时，常规的中值滤波的效果就不是很好了。有一个选择就是增大滤波器的窗口大小，这虽然在一定程度上能解决上述的问题，但是会给图像造成较大的模糊。</p>
<p>常规的中值滤波器的窗口尺寸是固定大小不变的，就<strong>不能同时兼顾去噪和保护图像的细节</strong>。这时就要寻求一种改变，根据预先设定好的条件，在滤波的过程中，<strong>动态的改变滤波器的窗口尺寸大小</strong>，这就是自适应中值滤波器 。在滤波的过程中，自适应中值滤波器会根据预先设定好的条件，改变滤波窗口的尺寸大小，同时还会根据一定的条件判断当前像素是不是噪声，如果是则用<strong>邻域中值</strong>替换掉当前像素；不是，则不作改变。</p>
<p>自适应中值滤波器有三个<strong>目的</strong>：</p>
<ul>
<li>滤除椒盐噪声</li>
<li>平滑其他非脉冲噪声</li>
<li>尽可能的保护图像中细节信息，避免图像边缘的细化或者粗化。</li>
</ul>
<p><strong>实现过程：</strong></p>
<p>对于每一个像素点的处理，使用一个while循环。在while循环中：</p>
<p>首先，在当前像素点下根据当前尺寸窗口的大小获取数据存入数组；</p>
<p>其次，获取窗口内像素的最大最小值和中值；</p>
<p>再，得到A1（中值 - 最小值），A2（中值 - 最大值）。</p>
<p>预先定义好以下符号：</p>
<p>Sxy：        滤波器的作用区域，滤波器窗口所覆盖的区域；<br>Zmin：    Sxy中最小的灰度值；<br>Zmax：    Sxy中最大的灰度值；<br>Zmed：    Sxy中所有灰度值的中值；<br>Zxy：        表示图像中对应像素点的灰度值；<br>Smax：    Sxy所允许的最大窗口尺寸；</p>
<p>自适应中值滤波器分为以下两个过程，A和B：</p>
<p>A:</p>
<ol>
<li>A1 = Zmed - Zmin</li>
<li>A2 = Zmed - Zmax</li>
<li>如果A1&gt;0 且 A2&lt;0，则跳转到B</li>
<li>否则，增大窗口的尺寸</li>
<li>如果增大后的尺寸 ≤ Smax，则重复A</li>
<li>否则，直接输出Zmed</li>
</ol>
<p>B：</p>
<ol>
<li>B1 = Zxy - Zmin</li>
<li>B2 = Zxy - Zmax</li>
<li>如果B1&gt;0 且 B2&lt;0，则输出Zxy</li>
<li>否则输出Zmed</li>
</ol>
<p><strong>实现原理：</strong></p>
<p><strong>A</strong>步骤实质是判断当前区域的中值点是否是噪声点，通常来说是满足条件的，此时中值点不是噪声点，跳转到<strong>B</strong>；考虑一些特殊情况，如果Zmed=Zmin或者Zmed=Zmax，则认为是噪声点，应该扩大窗口尺寸，在一个更大的范围内寻找一个合适的非噪声点，随后再跳转到<strong>B</strong>，否则输出的中值点是噪声点；</p>
<p>接下来考虑跳转到<strong>B</strong>之后的情况：判断中心点的像素值是否是噪声点，原理同上，因为如果Zxy=Zmin或者Zxy=Zmax，则认为是噪声点。如果不是噪声点，我们可以保留当前像素点的灰度值；如果是噪声点，则使用中值替代原始灰度值，滤去噪声。</p>
<h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>一种特殊形式的邻域滤波（邻域算子都是1/M*N）。</p>
<p>图片中一个方块区域（一般为3*3）内，中心点的像素为全部点像素值的平均值。均值滤波就是对于整张图片进行以上操作。</p>
<p><strong>缺陷</strong>：均值滤波本身存在着固有的缺陷，即它不能很好地保护图像细节，在图像去噪的同时也破坏了图像的细节部分，从而使<strong>图像变得模糊，不能很好地去除噪声点</strong>。特别是椒盐噪声</p>
<h4 id="算术均值滤波"><a href="#算术均值滤波" class="headerlink" title="算术均值滤波"></a>算术均值滤波</h4><p>这是<strong>最简单的均值滤波器，可以去除均匀噪声和高斯噪声，但会对图像造成一定程度的模糊</strong>。</p>
<p>算术均值滤波器就是简单的计算窗口区域的像素均值，然后将均值赋值给窗口中心点处的像素：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211210160750996-16402595643923.png" alt="image-20211210160750996" style="zoom:50%;">

<p>其中，g(s,t)表示原始图像，f(x,y)表示均值滤波后得到的图像，Sxy表示滤波器窗口。</p>
<p>基于上述公式，可以很容易的得到的算术均值滤波器的窗口模板，下面以3×3为例：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211210160926601-16402595643924.png" alt="image-20211210160926601" style="zoom:67%;">



<h4 id="几何均值滤波"><a href="#几何均值滤波" class="headerlink" title="几何均值滤波"></a>几何均值滤波</h4><p>滤波后图像的像素由模板窗口内像素的乘积的1/mn幂给出。 和算术均值滤波器相比，几何均值滤波器能够<strong>更好的取出高斯噪声，并且能够更多的保留图像的边缘信息</strong>。但其<strong>对0值是非常敏感</strong>的，在滤波器的窗口内只要有一个像素的灰度值为0，就会造成滤波器的输出结果为0。</p>
<p>公式如下：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211214172053056-16402595643925.png" alt="image-20211214172053056" style="zoom:50%;">



<h4 id="谐波均值滤波"><a href="#谐波均值滤波" class="headerlink" title="谐波均值滤波"></a>谐波均值滤波</h4><p><strong>对盐粒噪声（白噪声）效果较好，不适用于胡椒噪声；比较适合处理高斯噪声。</strong></p>
<p>公式如下：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211210161208708-16402595643926.png" alt="image-20211210161208708" style="zoom:50%;">



<h4 id="逆谐波均值滤波"><a href="#逆谐波均值滤波" class="headerlink" title="逆谐波均值滤波"></a>逆谐波均值滤波</h4><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211210163038627-16402595643927.png" alt="image-20211210163038627" style="zoom:67%;">

<p>其中Q称为滤波器的阶数，该滤波器可以用来<strong>消除椒盐噪声</strong>。但是不能同时处理盐粒噪声和胡椒噪声，当Q为正时，可以消除<strong>胡椒噪声</strong>；当Q为负时，消除<strong>盐粒噪声</strong>。当Q=0时，该滤波器退化为算术均值滤波器；Q=-1时，退化为谐波均值滤波器。</p>
<h4 id="修正后的alpha均值滤波"><a href="#修正后的alpha均值滤波" class="headerlink" title="修正后的alpha均值滤波"></a>修正后的alpha均值滤波</h4><p>假设在Sxy模板领域内，去掉g(s,t)中最高灰度值的d/2和最低灰度值的d/2个像素。用gr(s,t)来代替剩余的mn-d个像素。由剩余像素点的平均值形成的滤波器称为修正后的alpha均值滤波器：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211210173009541-16402595643938.png" alt="image-20211210173009541" style="zoom:67%;">

<p>其中d取0~m*n-1之间的任意数。</p>
<p>当d=0时，退变为算术均值滤波；</p>
<p>当d=(m*n-1)，退变为中值滤波器；</p>
<p>d取其他值时，该滤波器适用于包括多种噪声的情况，如高斯噪声和椒盐噪声混合的情况。</p>
<h3 id="最值滤波"><a href="#最值滤波" class="headerlink" title="最值滤波"></a>最值滤波</h3><h4 id="最大值和最小值滤波"><a href="#最大值和最小值滤波" class="headerlink" title="最大值和最小值滤波"></a>最大值和最小值滤波</h4><p>最值滤波就是取kernal排序后得最大值或最小值来取代中心像素作为输出。</p>
<p>分为最大值滤波和最小值滤波，分别相当于形态学操作的<strong>膨胀和腐蚀</strong>。</p>
<h4 id="中点滤波"><a href="#中点滤波" class="headerlink" title="中点滤波"></a>中点滤波</h4><p>在上述最值滤波的基础上，取最大值和最小值的平均值作为中心像素点的输出。</p>
<h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><p>双边滤波是一种非线性滤波器，它可以达到保持边缘、降噪平滑的效果。和其他滤波原理一样，双边滤波也是采用加权平均的方法，用周边像素亮度值的加权平均代表某个像素的强度，所用的加权平均基于高斯分布[1]。最重要的是，双边滤波的权重不仅考虑了像素的<strong>欧氏距离</strong>（如普通的高斯低通滤波，只考虑了位置对中心像素的影响），还考虑了像素范围域中的<strong>辐射差异</strong>（例如卷积核中像素与中心像素之间相似程度、颜色强度，深度距离等），在计算中心像素的时候同时考虑这两个权重。它是一种可以保边去噪的滤波器。之所以可以达到此去噪效果，是因为滤波器是由两个函数构成。一个函数是由<strong>几何空间距离</strong>决定滤波器系数。另一个由<strong>像素差值</strong>决定滤波器系数。</p>
<p>双边滤波的核函数是空间域核与像素范围域核的综合结果：<strong>在图像的平坦区域，像素值变化很小，对应的像素范围域权重接近于1，此时空间域权重起主要作用，相当于进行高斯模糊；在图像的边缘区域，像素值变化很大，像素范围域权重变大，从而保持了边缘的信息。</strong></p>
<p><strong>空间域</strong>公式如下：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211214142110264-16402595643939.png" alt="image-20211214142110264" style="zoom:50%;">

<p><strong>像素范围</strong>域（颜色域）公式如下：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211214142312682-164025956439310.png" alt="image-20211214142312682" style="zoom:50%;">

<p>他们的乘积即为双边滤波的权重：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211214145425919-164025956439311.png" alt="image-20211214145425919" style="zoom:50%;">

<p>根据权重计算最后目标点的像素值：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211214145506582-164025956439312.png" alt="image-20211214145506582" style="zoom:50%;">



<h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>高斯滤波器是一种线性滤波器，能够有效的抑制噪声，平滑图像。其作用原理和均值滤波器类似，都是取滤波器窗口内的像素的均值作为输出。其窗口模板的系数和均值滤波器不同，均值滤波器的模板系数都是相同的为1；而高斯滤波器的<strong>模板系数，则随着距离模板中心的增大而系数减小</strong>。所以，高斯滤波器相比于均值滤波器对图像个<strong>模糊程度较小</strong>。</p>
<p><strong>高斯滤波器</strong></p>
<p>二维高斯函数如下：</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/4caf5e01-f4ea-3bd4-85c4-a66b3d6e2c7e-164025956439313.png" alt="img"></p>
<p>其中e前的参数可以忽略，因为这只是个表示幅值的常数，并不影响相互之间的比例关系，并且最终都要进行归一化，所以实际只需要计算后半部分即可。该参数仅影响图像的亮度而不影响模糊。</p>
<p>例如，要产生一个3×3的高斯滤波器模板，以模板的中心位置为坐标原点进行取样。模板在各个位置的坐标，如下所示（x轴水平向右，y轴竖直向下）</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/439761-20170216214155582-1833428662-164025956439314.png" alt="img"></p>
<p>对于窗口模板的大小为 (2k+1)×(2k+1)，模板中各个元素值的计算公式如下：</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/20190502112714183-164025956439315.png" alt="img"></p>
<p>转化为代码：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">for(int i &#x3D; 0; i &lt; m; ++i)
    for(int j &#x3D; 0; j &lt; n; ++j)
        double g &#x3D; exp(((i - m&#x2F;2)*(i - m&#x2F;2) + (j - n&#x2F;2)*(j - n&#x2F;2)) * -1.0 &#x2F; (2 * sigma * sigma));</code></pre>

<p>再对求出来的每个g进行归一化（因为求的是加权平均，要保证窗口模板各元素和为1）</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">kernel &#x3D; g &#x2F; sum;</code></pre>

<p>关于高斯分布的<strong>标准差σ的选值</strong>，代表着数据的离散程度。如果σ较小，那么生成的模板的中心系数较大，而周围的系数较小，这样对图像的平滑效果就不是很明显；反之，σ较大，则生成的模板的各个系数相差就不是很大，比较类似均值模板，对图像的平滑效果比较明显。</p>
<p>高斯分布的概率分布密度图如下：</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/439761-20170216214529738-2113566517-164025956439316.png" alt="img"></p>
<p>横轴表示可能得取值x，竖轴表示概率分布密度F(x)，那么不难理解这样一个曲线与x轴围成的图形面积为1。σσ（标准差）决定了这个图形的宽度，可以得出这样的结论：σσ越大，则图形越宽，尖峰越小，图形较为平缓；σσ越小，则图形越窄，越集中，中间部分也就越尖，图形变化比较剧烈。这其实很好理解，如果sigma也就是标准差越大，则表示该密度分布一定比较分散，由于面积为1，于是尖峰部分减小，宽度越宽（分布越分散）；同理，当σσ越小时，说明密度分布较为集中，于是尖峰越尖，宽度越窄！</p>
<p>以上求出来的就是模板系数，滤波操作就是分别以图像的每个像素点为中心再根据模板系数求出加权平均像素，作为该点的滤波后像素。比如3x3模板，对选中像素点的外一圈共九个像素点，分别乘以对应位置的模板系数再求和，即为选中点的像素。</p>
<h2 id="高通滤波（边缘检测）"><a href="#高通滤波（边缘检测）" class="headerlink" title="高通滤波（边缘检测）"></a>高通滤波（边缘检测）</h2><p>如何识别图像边缘？图里面有一条线,左边很亮,右边很暗,那人眼就很容易识别这条线作为边缘.也就是<strong>像素的灰度值快速变化的地方</strong>，那么如何来数学化这个问题，就是<strong>梯度。</strong></p>
<ol>
<li>要获得一幅图像的梯度，就需要在图像的每个像素点计算对x和对y的偏导数，也就是 **gx = f(x+1,y) - f(x,y) 和 gy = f(x,y+1) - f(x,y)**，转化为模板也就是，水平和垂直的 <strong>[-1,1]</strong> 模板。</li>
<li>而当我们对对角线方向的边缘感兴趣时，就产生了<strong>Roberts算子</strong>，原理就是把一维的模板斜过来。</li>
<li>Roberts算子中2x2的模板在概念上很简单，但在实际应用中，它对于用关于中心点对称的模板来计算边缘方向不是很有用。相对来说3x3考虑了中心点对端数据的性质，并携带了关于边缘方向的更多信息。于是就产生了 <strong>Prewitt算子</strong>。它的3x3模板考虑到了水平/垂直和斜边的信息，相比于Roberts更准确。</li>
<li>在Prewitt的基础上，在卷积核的中心位置处使用2代替1，<strong>能较为有效的平滑图像，抑制噪声</strong>，这就是<strong>Sobel算子</strong>。而针对不同的需求，可以设计不同的卷积核，例如需要对对角线方向有更好的响应，那么可以将2设置在卷积核的两个对角。</li>
</ol>
<h3 id="Roberts算子"><a href="#Roberts算子" class="headerlink" title="Roberts算子"></a>Roberts算子</h3><p>Roberts算子是一种最简单的算子，利用<strong>局部差分</strong>寻找边缘的算子。采用对角线相邻两像素之差近似梯度幅值检测边缘。检测<strong>垂直边缘的效果比斜向边缘要好</strong>，定位精度高，对噪声比较敏感，无法抑制噪声的影响。</p>
<p>Roberts边缘算子是一个2x2的模板，采用的是对角方向相邻的两个像素之差。从图像处理的实际效果来看，边缘定位较准，对噪声敏感。模板如下：</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/v2-284a63fee4b9188ad867f10f9f9bf6fe_1440w-164025956439317.jpg" alt="img"></p>
<p>对于输入图像f(x,y),使用Roberts算子后输出的目标图像为g(x,y),则</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/v2-63587385584cf73f70733e2476279903_1440w-164025956439318.png" alt="img"></p>
<h3 id="Sobel算子（一阶导数法）"><a href="#Sobel算子（一阶导数法）" class="headerlink" title="Sobel算子（一阶导数法）"></a>Sobel算子（一阶导数法）</h3><p><strong>基于寻找梯度强度</strong></p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/583030-20190929174912027-119968080-164025956439319.png" alt="img"></p>
<p>对于f(t),其导数f’(t)反映了每一处的变化趋势.在变化最快的位置其导数最大. sobel算子的思路就是模拟求一阶导数.</p>
<p>sobel算子是一个离散差分算子.它计算图像像素点亮度值的近似梯度。图像是二维的,即沿着宽度/高度两个方向。我们使用两个卷积核对原图像进行处理:</p>
<p>水平方向：</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/583030-20190929161108392-1943506049-164025956439320.png" alt="img"></p>
<p>原始像素灰度值–&gt;(右边像素值-左边像素值),反映了水平方向的变化情况.</p>
<p>垂直方向同理：</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/583030-20190929161120966-1646377214-164025956439321.png" alt="img"></p>
<p>这样就得到了两个新的矩阵,分别反映了每一点像素在水平方向上的亮度变化情况和在垂直方向上的亮度变换情况。</p>
<p>综合考虑这两个方向的变化，使用<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/583030-20190929161733111-1912218409-164025956439322.png" alt="img">反映某个像素的梯度变化情况.</p>
<p>有时候为了简单起见,也直接用绝对值相加替代：<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/583030-20190929161841863-988164813-164025956439323.png" alt="img"></p>
<p>在opencv中也可以通过以下卷积核（Scharr）大像素的变化情况：</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/583030-20190929162114665-950047722-164025956439324.png" alt="img"></p>
<p>与滤波一样，对每个像素点的处理为：要操作像素点对应于Gx，Gy矩阵中心，对该像素点和周边9个像素点乘以相应系数求和，得到一个方向上的处理结果。完整的Sobel算子则需要对两个方向上的处理结果求和，得到完整的新像素值。</p>
<p><font color="red"><strong>opencv的Sobel函数</strong></font></p>
<p><strong>1.采用了可分离的卷积核</strong></p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/v2-ca8a3f87bdf380be3f64c68891545da2_1440w.jpg" alt="img"></p>
<p>图A是可分离的；它可以表示为两个一维卷积（B和C）；D是一个不可分割内核的例子。<strong>可分离的内核是可以被认为是两个一维的内核，首先与x内核进行卷积然后与y内核进行卷积来应用</strong>。这种分解的好处是内核卷积的计算成本大约是图像面积乘以内核区域。这意味着用n×n内核卷积区域A的图像需要时间与<strong>An2</strong>成正比，同时n×1内核与图像卷积一次，然后与1×n内核卷积占用与An + An = 2An成比例。</p>
<p><strong>随着图像尺寸与卷积核尺寸的增大，用分离的卷积核依次对图像进行卷积操作，可以有效地提高运算速度。因此，在二维图像处理中，经常将一个可分离卷积核分解为一维水平核 kernalX 和一维垂直核 kernalY 的乘积。</strong></p>
<p>秩为 1 的矩阵可以分解为一个列向量与一个行向量的乘积，因此秩为 1 的卷积核是可分离卷积核。</p>
<p>可分离卷积核 w 与图像 f 的卷积（same 卷积），等于先用 f 与 w1 卷积，再用 w2 对结果进行卷积：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20220328111400326.png" alt="image-20220328111400326" style="zoom:67%;">

<p><strong>2.行、列卷积核的生成</strong></p>
<p>阅读源码：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">for( int k &#x3D; 0; k &lt; 2; k++ )	&#x2F;&#x2F; 分别生成行、列
&#123;
    Mat* kernel &#x3D; k &#x3D;&#x3D; 0 ? &amp;kx : &amp;ky;
    int order &#x3D; k &#x3D;&#x3D; 0 ? dx : dy;
    int ksize &#x3D; k &#x3D;&#x3D; 0 ? ksizeX : ksizeY;	&#x2F;&#x2F; ksize都是相同的

    CV_Assert( ksize &gt; order );

    if( ksize &#x3D;&#x3D; 1 )
        kerI[0] &#x3D; 1;
    else if( ksize &#x3D;&#x3D; 3 )	&#x2F;&#x2F; 卷积核大小设为3时使用固定值
    &#123;
        if( order &#x3D;&#x3D; 0 )
            kerI[0] &#x3D; 1, kerI[1] &#x3D; 2, kerI[2] &#x3D; 1;
        else if( order &#x3D;&#x3D; 1 )
            kerI[0] &#x3D; -1, kerI[1] &#x3D; 0, kerI[2] &#x3D; 1;
        else
            kerI[0] &#x3D; 1, kerI[1] &#x3D; -2, kerI[2] &#x3D; 1;
    &#125;
    else	&#x2F;&#x2F; 大于3时进行计算，巧妙
    &#123;
        int oldval, newval;
        kerI[0] &#x3D; 1;
        for( i &#x3D; 0; i &lt; ksize; i++ )
            kerI[i+1] &#x3D; 0;

        for( i &#x3D; 0; i &lt; ksize - order - 1; i++ )
        &#123;
            oldval &#x3D; kerI[0];
            for( j &#x3D; 1; j &lt;&#x3D; ksize; j++ )
            &#123;
                newval &#x3D; kerI[j]+kerI[j-1];
                kerI[j-1] &#x3D; oldval;
                oldval &#x3D; newval;
            &#125;
        &#125;

        for( i &#x3D; 0; i &lt; order; i++ )
        &#123;
            oldval &#x3D; -kerI[0];
            for( j &#x3D; 1; j &lt;&#x3D; ksize; j++ )
            &#123;
                newval &#x3D; kerI[j-1] - kerI[j];
                kerI[j-1] &#x3D; oldval;
                oldval &#x3D; newval;
            &#125;
        &#125;
        &#x2F;&#x2F; 以上计算，假设ksize&#x3D;5，order&#x3D;1，可得一维核：[-1，-2，0，2，1]
    &#125;
&#125;</code></pre>

<p>设ksize=3，dx=1，dy=0，带入运算可得：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20220328112628256.png" alt="image-20220328112628256" style="zoom:67%;">

<p>卷积核的效果和二维的是相同的。</p>
<p><strong>3.可分离卷积的计算</strong></p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/i=20210310094136247.png" alt="在这里插入图片描述" style="zoom:80%;">

<p>我们首先在5x5图像上用3x1卷积。这样的话卷积核就能横向扫描5个位置，纵向扫描3个位置，如上图所标的点所示。</p>
<p>现在得到的是一个3x5的矩阵，这个矩阵经过1x3卷积核的卷积操作——从横向上的 3 个位置以及纵向上的 3个位置来扫描该矩阵。</p>
<h3 id="Prewitt算子"><a href="#Prewitt算子" class="headerlink" title="Prewitt算子"></a>Prewitt算子</h3><p>Prewitt算子的原理和sobel是一模一样的，唯一的区别就是卷积核存在差异：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211216204046572-164025956439325.png" alt="image-20211216204046572" style="zoom:50%;">

<p>Sobel相较于Prewitt，<strong>在中心权值上使用2来代替1，这样可以较好的抑制噪声。</strong></p>
<h3 id="Laplacian算子（二阶微分法）"><a href="#Laplacian算子（二阶微分法）" class="headerlink" title="Laplacian算子（二阶微分法）"></a>Laplacian算子（二阶微分法）</h3><p><strong>基于过零点检测</strong></p>
<p>对Sobel算子中的一阶导数函数再次求导可得：</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/583030-20190930104504107-1830102038-164025956439326.png" alt="img"></p>
<p>二阶差分公式：<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/810956-20150926131132084-1009704410.gif" alt="azzz"></p>
<p>Laplace算子的差分形式：</p>
<p>分别对Laplace算子x,y两个方向的二阶导数进行差分就得到了离散函数的Laplace算子。在一个二维函数f(x,y)中，x,y两个方向的二阶差分分别为：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211210153218813-164025956439327.png" alt="image-20211210153218813" style="zoom: 67%;">

<p>于是可得Laplace算子的差分形式为：</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/810956-20150926131132084-1009704410-16418119874511.gif" alt="azzzzz"></p>
<p>写作滤波模板的形式如下：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211210153440871-164025956439329.png" alt="image-20211210153440871" style="zoom: 50%;">

<p>注意该模板的特点，在上下左右四个90度的方向上结果相同，也就是说在90度方向上无方向性。为了让该mask在45度的方向上也具有该性质，可以对该模板进行扩展定义为：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211210153934870-164025956439328.png" alt="image-20211210153934870" style="zoom:50%;">

<p>注：定义数字形式的拉普拉斯要求系数之和必为0。</p>
<p>之后的操作与其他的空间滤波操作相同。将模板在原图上逐行移动，然后模板中各系数与其重合的像素相乘后求和，赋给与mask中心重合的像素。</p>
<p><strong>拉普拉斯对噪声敏感，会产生双边效果。不能检测出边的方向。通常不直接用于边的检测，只起辅助的角色，检测一个像素是在边的亮的一边还是暗的一边利用零跨越，确定边的位置。</strong></p>
<h3 id="Canny算子"><a href="#Canny算子" class="headerlink" title="Canny算子"></a>Canny算子</h3><p>图像边缘信息主要集中在高频段，通常说图像锐化或检测边缘，实质就是高频滤波。</p>
<p>微分运算是求信号的变化率，具有加强高频分量的作用。在空域运算中来说，对图像的锐化就是计算微分。由于数字图像的离散信号，微分运算就变成计算差分或梯度。</p>
<p>因此canny算子求边缘点分为以下四步：</p>
<p><strong>1.使用高斯滤波器平滑图像</strong></p>
<p>卷积的核心意义就是获取原始图像中像模板特征的性质。</p>
<p><strong>2.用一阶偏导有限差分（Sobel）计算梯度值和方向</strong></p>
<p>经典Canny算法用了四个梯度算子来分别计算水平，垂直和对角线方向的梯度。但是通常都不用四个梯度算子来分别计算四个方向。常用的边缘差分算子（如Rober，Prewitt，Sobel）计算水平和垂直方向的差分Gx和Gy。这样就可以如下计算梯度模和方向：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/1095344-20170213171940019-134049094-164025956439330.jpg" alt="img" style="zoom:80%;">

<p>梯度角度θ范围从弧度-π到π，然后把它近似到四个方向，分别代表水平，垂直和两个对角线方向（0°,45°,90°,135°）。</p>
<p>由于图像的坐标系是以左上角为原点向右和下延展，因此根据像素点计算出的角度值必然在一、四象限。那么可以分别以 ± π / 8（水平） 、π / 8 ~ 3π / 8（45°）、- π / 8 ~ - 3π / 8（-45°）、一四象限剩余部分（垂直）来分割，落在每个区域的梯度角给一个特定值，代表四个方向之一。</p>
<p><strong>3.对梯度幅值进行非极大值抑制</strong></p>
<p>意义就是寻找像素点局部最大值。</p>
<p>沿着梯度方向，比较它前面和后面的梯度值即可（对于左右边界，则比较附近的两个值）。如果是最大值就保留，否则置为0。</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/621547-20160122165656406-4766340-164025956439331.jpg" alt="img"></p>
<p>如上图，c点为需要判断的点，按照2中划分的四个区域，可以看到每个区域包含了八邻域中的两个点，通过判断c点的角度值所在区域，与该区域包含的那两个点进行比较即可。</p>
<p>若想提高精度，如上右图：c的角度值在π / 8 ~ 3π / 8（45°）区域，不比较g1和g4，而是比较dTmp1和dTmp2，由于这两个点都是浮点坐标，因此需要采用线性插值方法来计算这两个点的幅值。</p>
<p>通过角度θ可以计算出dTmp1在g1和g2之间的比例，设dis(dTmp1，g2) = w，则dis(g1，dTmp1) = 1 - w。所以dTmp1的幅值为：w * g2 + （1 - w）* g1。同理可得dTmp2的幅值。将c的幅值与这两个浮点坐标的幅值进行比较进行非极大值抑制。</p>
<p><strong>4.用双阈值算法检测、连接边缘</strong></p>
<p>一般的边缘检测算法用一个阈值来滤除噪声或颜色变化引起的小的梯度值，而保留大的梯度值。Canny算法应用双阈值，即一个高阈值和一个低阈值来区分边缘像素。如果边缘像素点梯度值大于高阈值，则被认为是强边缘点。如果边缘梯度值小于高阈值，大于低阈值，则标记为弱边缘点。小于低阈值的点则被抑制掉。</p>
<p><font color="red">一般来说，建议高低阈值的比率为2：1或3：1</font></p>
<p><strong>4.5.滞后边界跟踪</strong></p>
<p>强边缘点可以认为是真的边缘。弱边缘点则可能是真的边缘，也可能是噪声或颜色变化引起的。为得到精确的结果，后者引起的弱边缘点应该去掉。通常认为<strong>真实边缘引起的弱边缘点和强边缘点是连通的</strong>，而又噪声引起的弱边缘点则不会。所谓的滞后边界跟踪算法<strong>检查一个弱边缘点的8连通领域像素</strong>，只要有强边缘点存在，那么这个弱边缘点被认为是真是边缘保留下来。</p>
<p>只需对所有被标记过的弱边缘点的八邻域进行遍历，若邻域中存在强边缘点，则保留；否则抑制掉。</p>
<h3 id="方向算子"><a href="#方向算子" class="headerlink" title="方向算子"></a>方向算子</h3><p>方向算子利用一组模板分别计算在不同方向上的差分值，取其中最大的值作为边缘强度，而将与之对应的方向作为边缘方向。</p>
<h4 id="Kirsch算子"><a href="#Kirsch算子" class="headerlink" title="Kirsch算子"></a>Kirsch算子</h4><p>类似于Sobel算子，也利用图像中某点的梯度幅值作为像素的灰度值，Sobel算子计算出某点两个方向的梯度值，Gx、Gy；但Kirsch算子 利用8个卷积模板计算出了<strong>某点8个方向的梯度幅值和方向</strong>，并以最大的卷积值作为该点的灰度值。</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211211151831396-164025956439332.png" alt="image-20211211151831396"></p>
<p>对每个像素点都用 这8个模板进行进行卷积（注意，每个卷积值都应取绝对值），求出该点的最大卷积值。</p>
<h4 id="Nevitia算子"><a href="#Nevitia算子" class="headerlink" title="Nevitia算子"></a>Nevitia算子</h4><p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211211163622445-164025956439333.png" alt="image-20211211163622445"></p>
<h2 id="形态学"><a href="#形态学" class="headerlink" title="形态学"></a>形态学</h2><h3 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h3><p>膨胀的操作本质上来说和滤波是一样的，采用滑动窗口（为像素点指定邻域）的模式去遍历整张图，来调整像素值。</p>
<p>调整方式为：选取像素点及其指定邻域中的<strong>极大值</strong>，作为该像素点的新值。</p>
<p>膨胀同sobel一样存在方向性，可以通过改变邻域的形状，来控制膨胀的方向。</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20220718153424903.png" alt="image-20220718153424903" style="zoom: 67%;">

<h3 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h3><p>腐蚀与膨胀的原理相同。</p>
<p>调整方式为：选取像素点及其指定邻域中的<strong>极小值</strong>，作为该像素点的新值。</p>
<p>膨胀和腐蚀是针对图像中的高亮部分的变化来说的。</p>
<p>膨胀和腐蚀常用于二值图的操作。</p>
<h2 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h2><h3 id="直线检测"><a href="#直线检测" class="headerlink" title="直线检测"></a>直线检测</h3><h4 id="标准霍夫变换"><a href="#标准霍夫变换" class="headerlink" title="标准霍夫变换"></a>标准霍夫变换</h4><p>首先该检测算法的输入图像只能是边缘二值图像。</p>
<p><strong>1.一条直线在图像二维空间可由两个变量表示：</strong></p>
<p>· 在笛卡尔坐标系：<strong>y = kx + b</strong>，可由k、b表示。</p>
<p>· 在极坐标系：<strong>ρ = xcosθ + ysinθ</strong>，可由ρ、θ表示</p>
<p><strong>2.对于点（x0，y0），可将经过这个点的一簇直线定义为ρ = x0cosθ + y0sinθ</strong></p>
<p><strong>2.很自然的，对于两个点，满足同一对（ρ，θ）时，这两个点处于同一直线上</strong></p>
<p><strong>3.于是，当有更多个点满足同一对（ρ，θ）时，该对表示的直线由更多的点组成.。一般可以通过设置直线上点的阈值来定义多少个点组成的（ρ，θ）能被认为是一条直线。</strong></p>
<p><strong>4.霍夫变换追踪图像中每个点对应的所有（ρ，θ）并记录数量，若超过了阈值, 那么可以认为这个交点所代表的参数对在原图像中为一条直线。</strong></p>
<p><strong>代码实现</strong></p>
<p>对于图像的每个像素点，遍历 [0, PI] 共180个θ值，得到相应的ρ，并对每一组（ρ，θ）记录值+1（计分板）。</p>
<p>遍历计分板，找出分数大于设定阈值的（ρ，θ）对，即为检测到的直线参数，再将其还原为数学概念上的直线即可。</p>
<h4 id="累计概率霍夫变换（常用）"><a href="#累计概率霍夫变换（常用）" class="headerlink" title="累计概率霍夫变换（常用）"></a>累计概率霍夫变换（常用）</h4><p>它是对标准霍夫变换的改进。在一定的范围内进行霍夫变换，计算单独线段的方向以及范围，从而减少计算量，缩短计算时间。之所以称PPHT为“概率”的，是因为并不将累加器平面内的所有可能的点累加，而只是累加其中的一部分，该想法是如果峰值如果足够高，只用一小部分时间去寻找它就够了。这样猜想的话，可以实质性地减少计算时间。</p>
<p><strong>代码实现</strong></p>
<p>1.随机获取边缘图像上的前景点，映射到极坐标系画曲线；</p>
<p>2.当极坐标系里面有交点达到最小投票数，将该点对应x-y坐标系的直线L找出来；</p>
<p>3.搜索边缘图像上前景点，在直线L上的点（且点与点之间距离小于maxLineGap的）连成线段，然后这些点全部删除，并且记录该线段的参数（起始点和终止点），当然线段长度要满足最小长度；</p>
<p>4.重复1. 2. 3.。</p>
<p><strong>opencv函数</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">HoughLinesP(InputArray image, OutputArray lines, double	rho, double theta, int threshold,
double minLineLength &#x3D; 0, double maxLineGap &#x3D; 0)</code></pre>

<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xpX2hhaXl1,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<h2 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h2><p><strong>池化的作用：</strong>减少特征图大小，也就是可以减少计算量和所需显存。</p>
<h3 id="平均池化（mean-pooling）"><a href="#平均池化（mean-pooling）" class="headerlink" title="平均池化（mean-pooling）"></a>平均池化（mean-pooling）</h3><p>即对邻域内特征点只求平均</p>
<p>优缺点：<strong>能很好的保留背景，但容易使得图片变模糊</strong></p>
<p>正向传播：邻域内取平均</p>
<p>反向传播：特征值根据领域大小被平均，然后传给每个索引位置</p>
<h3 id="最大池化（max-pooling）"><a href="#最大池化（max-pooling）" class="headerlink" title="最大池化（max-pooling）"></a>最大池化（max-pooling）</h3><p>即对邻域内特征点取最大</p>
<p>优缺点：<strong>能很好的保留纹理特征，一般现在都用最大而很少用平均</strong></p>
<p>正向传播：取邻域内最大，并记住最大值的索引位置，以方便反向传播</p>
<p>反向传播：将特征值填充到正向传播中，值最大的索引位置，其他位置补0</p>
<h3 id="随机池化（stochastic-pooling）"><a href="#随机池化（stochastic-pooling）" class="headerlink" title="随机池化（stochastic-pooling）"></a>随机池化（stochastic-pooling）</h3><p>只需对邻域中的元素按照其概率值大小随机选择，即元素值大的被选中的概率也大。而不像max-pooling那样，永远只取那个最大值元素。</p>
<p>在区域内，将左图的数值进行归一化处理，即 1/（1+2+3+4）=0.1；2/10=0.2；3/10=0.3；4/10=0.4</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211223190801508-164025956439334.png" alt="image-20211223190801508" style="zoom: 67%;">

<p>正向传播：对矩阵区域求加权平均即可，比如上面图中，池化输出值为：1 * 0.1+2 * 0.2+3 * 0.3+4 * 0.4=<strong>3</strong>。</p>
<p>反向传播：只需保留前向传播已经记录被选中节点的位置的值，其它值都为0,这和max-pooling的反向传播非常类似。</p>
<p>优点：<strong>方法简单，泛化能力更强（带有随机性）</strong></p>
<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><h3 id="亮度与对比度"><a href="#亮度与对比度" class="headerlink" title="亮度与对比度"></a>亮度与对比度</h3><h4 id="基础线性变化"><a href="#基础线性变化" class="headerlink" title="基础线性变化"></a>基础线性变化</h4><p>在查询opencv的亮度与对比度变化算法时，大多是博客都采用的最基础的线性变换：</p>
<p>​                                                                <strong>out = in * α + β</strong></p>
<p>其中 α 为对比度的变化，β 为亮度变化。</p>
<p><strong>亮度（β）：</strong>像素点的值就是0~255，0为黑表示最暗，255为白表示最亮。因此调节亮度就是简单的对像素值进行增减即可，即 <strong>β ∈ (-100，-100)</strong> 。</p>
<p><strong>对比度（α）：</strong>这里就存在问题了，线性变化的对比度调节非常不明显，在视觉上依旧呈现的是亮度的变化，在进行代码编写的时候一直达不到Photoshop里面的对比度调节效果。</p>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>通过查阅资料不难发现，对比度的调节原理如下：</p>
<p>对比度反应了图片上亮区域和暗区域的层次感。而反应到图像编辑上，调整对比度就是在保证<strong>平均亮度</strong>不变的情况下，扩大或缩小<strong>亮的点和暗的点的差异</strong>。既然是要保证平均亮度不变，所以对每个点的调整比例必须作用在<strong>该值和平均亮度的差值</strong>之上，这样才能够保证计算后的平均亮度不变。</p>
<p>因此很容易得出对比度变化的调整公式如下：</p>
<p>​                                                    <strong>out = (in - average) * α + in</strong></p>
<p>其中average为图像的平均亮度，α ∈ (-1，1) 。</p>
<p>但是实际处理中，并没有太多的必要去计算一张图的平均亮度：一来耗时间，二来在平均亮度上的精确度并不会给图像的处理带来太多的好处。因此一般<strong>假设一张图的平均亮度为127</strong>，即一半亮度，而一张正常拍照拍出来的图平均亮度应该是在[100,150]。在视觉上基本没有任何区别。</p>
<p>于是可得最终的亮度对比度调节公式：</p>
<p>​                                                    <strong>out = (in - average) * α + in + β</strong></p>
<p>达到了和Photoshop相同的效果。</p>
<h3 id="通道混合"><a href="#通道混合" class="headerlink" title="通道混合"></a>通道混合</h3><p>也就是<strong>调整某一个通道中的颜色成分</strong>，可以理解为调整图片某一颜色区域的颜色。</p>
<p>对于<strong>选中通道的每一个像素值</strong>，进行如下变换：</p>
<p>​                            <strong>out = red * r + green * g + blue * b + constant * 255</strong></p>
<p>其中，<strong>red、green、blue ∈ (-2, 2)</strong> ，**constant ∈ (-1, 1)**，r、g、b为每一个像素点的三个通道的值。</p>
<h3 id="gamma变换（校正）"><a href="#gamma变换（校正）" class="headerlink" title="gamma变换（校正）"></a>gamma变换（校正）</h3><p>Gamma校正是一种非常重要的非线性变换。对输入图像的灰度值进行指数变换，进而校正亮度偏差，通常应用于<strong>扩展暗调的细节</strong>。gamma校正可使得图像看起来更符合人眼的特性。</p>
<p>但其实Gamma校正不仅会改变亮度，还会改变彩色图像中rgb的比率。</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/1357029831_5904-16474189847913.png" alt="1357029831_5904"></p>
<p>当Gamma校正的值大于1时，图像的高光部分被压缩而暗调部分被扩展，图像整体变暗；</p>
<p>当Gamma校正的值小于1时，图像的高光部分被压缩而暗调部分被压缩，图像整体变亮。</p>
<p><strong>gamma校正的作用：</strong></p>
<p>1.人眼对外界光源的感光值与输入光强不是呈线性关系的，而是呈指数型关系的。在低照度下，人眼更容易分辨出亮度的变化，随着照度的增加，人眼不易分辨出亮度的变化。而摄像机感光与输入光强呈线性关系。</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/aHR0cHM6Ly93d3cuemRhaW90LmNvbS8lRTglQUUlQTElRTclQUUlOTclRTYlOUMlQkElRTglQTclODYlRTglQTclODkvR2FtbWElRTclOUYlQUIlRTYlQUQlQTMvLzE1MzUxNzU5NTk1MTUucG5n.png" alt="img"></p>
<p>2.为能更有效的保存图像亮度信息。未经Gamma变换和经过Gamma变换保存图像信息如下所示：可以观察到，未经Gamma变换的情况下，低灰度时，有较大范围的灰度值被保存成同一个值，造成信息丢失；同时高灰度值时，很多比较接近的灰度值却被保存成不同的值，造成空间浪费。经过Gamma变换后，改善了存储的有效性和效率。</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/aHR0cHM6Ly93d3cuemRhaW90LmNvbS8lRTglQUUlQTElRTclQUUlOTclRTYlOUMlQkElRTglQTclODYlRTglQTclODkvR2FtbWElRTclOUYlQUIlRTYlQUQlQTMvMTUzNTE3NjA3Mjk1NS5wbmc.png" alt="在这里插入图片描述"></p>
<p>Gamma校正主要应用在<strong>图像增强、目标检测以及图像分析</strong>等领域。表达式如下：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/v2-58d0f7160ef3cc1db393f612bf56c56c_1440w-164025956439335.jpg" alt="img" style="zoom:67%;">

<p><strong>代码实现</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">unsigned char newPixel &#x3D; static_cast&lt;unsigned char&gt;(pow(pixel &#x2F; 255.0, gamma) * 255);</code></pre>



<h3 id="图像的归一化"><a href="#图像的归一化" class="headerlink" title="图像的归一化"></a>图像的归一化</h3><p>所谓归一化，就是把需要处理的数据限制在你需要的一定范围内。</p>
<p>首先归一化是为了后面<strong>数据处理的方便</strong>，其次是保证<strong>程序运行时收敛加快</strong>。归一化的具体作用是<strong>归纳统一样本的统计分布性</strong>。归一化在0-1之间是统计的概率分布，归一化在某个区间上是统计的坐标分布。</p>
<p>而图像的归一化用的最多的就是<strong>归一化到（min，max）范围内：</strong></p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211217182736311-164025956439336.png" alt="image-20211217182736311" style="zoom: 50%;">

<p><strong>代码实现</strong></p>
<p>首先迭代整个图的像素点，获取max( src( x，y ) )和min像素点。</p>
<p>然后再次迭代整张图的像素点，将低于min的设置为min，高于max 的设置为max，在（min，max）之间的通过上式计算即可。</p>
<h3 id="图像的均衡化"><a href="#图像的均衡化" class="headerlink" title="图像的均衡化"></a>图像的均衡化</h3><p>直方图均衡化，是对图像像素值进行<strong>非线性拉伸</strong>，使得<strong>一定范围内像素值的数量的大致相同</strong>。这样原来直方图中的封顶部分对比度得到了增强，而两侧波谷的对比度降低，输出的直方图是一个较为平坦的分段直方图。如下图所示：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211217183206631-164025956439337.png" alt="image-20211217183206631" style="zoom:50%;">

<p>通过这种方法可以按照需要对图像的亮度进行调整，并且，这种方法是<strong>可逆</strong>的，也就是说知道了均衡化函数，也可以恢复原始的直方图。</p>
<p><strong>为什么要选用累积分布函数?</strong></p>
<p>均衡化过程中，必须要保证两个条件：①像素无论怎么映射，一定要保证原来的大小关系不变，较亮的区域，依旧是较亮的，较暗依旧暗，<strong>只是对比度增大，绝对不能明暗颠倒</strong>；②如果是八位图像，那么像素映射函数的值域应在0和255之间的，<strong>不能越界</strong>。综合以上两个条件，累积分布函数是个好的选择，因为<strong>累积分布函数是单调增函数</strong>（控制大小关系），并且<strong>值域是0到1</strong>（控制越界问题），所以直方图均衡化中使用的是累积分布函数。</p>
<p><strong>为什么使用累积分布函数处理后像素值会均匀分布？</strong></p>
<p>比较概率分布函数和累积分布函数，前者的二维图像是参差不齐的，后者是单调递增的。直方图均衡化过程中，映射方法是：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/758959-20160720114303966-941326077-164025956439338.jpg" alt="img" style="zoom: 80%;">

<p>其中，n是图像中像素点的总数，nk是当前灰度级的像素个数，L是图像中可能的灰度级总数。</p>
<p>于是对于像素值为k的点，只需要计算： 像素为0~k的点的数量 / 像素点总数，就可以得到直方图中的纵坐标（比例）。再乘以255，即为该点经过均衡化后的像素点。</p>
<h3 id="RGB转灰度"><a href="#RGB转灰度" class="headerlink" title="RGB转灰度"></a>RGB转灰度</h3><p><strong>一、基础</strong></p>
<p>对于彩色转灰度，有一个很著名的心理学公式：</p>
<p><strong>Gray = R * 0.299 + G * 0.587 + B * 0.114</strong></p>
<p><strong>二、整数算法</strong></p>
<p>而实际应用时，希望避免低速的浮点运算，所以需要整数算法。</p>
<p>注意到系数都是3位精度的没有，我们可以将它们缩放1000倍来实现整数运算算法：</p>
<p><strong>Gray = (R * 299 + G * 587 + B * 114 + 500)  / 1000</strong></p>
<p>RGB一般是8位精度，现在缩放1000倍，所以上面的运算是32位整型的运算。注意后面那个除法是整数除法，所以需要加上500来实现四舍五入。</p>
<p><strong>三、整数移位算法</strong></p>
<p>上面的整数算法已经很快了，但是有一点仍制约速度，就是最后的那个除法。移位比除法快多了，所以可以将系数缩放成 2的整数幂。</p>
<p>习惯上使用16位精度，2的16次幂是65536，所以这样计算系数：</p>
<p>0.299 * 65536 = 19595.264 ≈ <strong>19595</strong></p>
<p>0.587 * 65536 + (0.264) = 38469.632 + 0.264 = 38469.896 ≈ <strong>38469</strong></p>
<p>0.114 * 65536 + (0.896) =  7471.104 + 0.896 = <strong>7472</strong></p>
<p>这所使用的舍入方式不是四舍五入。四舍五入会有较大的误差，应该将以前的计算结果的误差一起计算进去，舍入方式是去尾法，表达式是：</p>
<p><strong>Gray = (R * 19595 + G * 38469 + B * 7472)  &gt;&gt; 16</strong></p>
<p>同理，2至20位精度的系数：</p>
<p>Gray = (R * 1 + G * 2 + B * 1) &gt;&gt; 2<br>Gray = (R * 2 + G * 5 + B * 1) &gt;&gt; 3<br>Gray = (R * 4 + G * 10 + B * 2) &gt;&gt; 4<br>Gray = (R * 9 + G * 19 + B * 4) &gt;&gt; 5<br>Gray = (R * 19 + G * 37 + B * 8) &gt;&gt; 6<br><strong>Gray = (R * 38 + G * 75 + B * 15) &gt;&gt; 7</strong><br>Gray = (R * 76 + G * 150 + B * 30) &gt;&gt; 8<br>Gray = (R * 153 + G * 300 + B * 59) &gt;&gt; 9<br>Gray = (R * 306 + G * 601 + B * 117) &gt;&gt; 10<br>Gray = (R * 612 + G * 1202 + B * 234) &gt;&gt; 11<br>Gray = (R * 1224 + G * 2405 + B * 467) &gt;&gt; 12<br>Gray = (R * 2449 + G * 4809 + B * 934) &gt;&gt; 13<br>Gray = (R * 4898 + G * 9618 + B * 1868) &gt;&gt; 14<br>Gray = (R * 9797 + G * 19235 + B * 3736) &gt;&gt; 15<br>Gray = (R * 19595 + G * 38469 + B * 7472) &gt;&gt; 16<br>Gray = (R * 39190 + G * 76939 + B * 14943) &gt;&gt; 17<br>Gray = (R * 78381 + G * 153878 + B * 29885) &gt;&gt; 18<br>Gray = (R * 156762 + G * 307757 + B * 59769) &gt;&gt; 19<br>Gray = (R * 313524 + G * 615514 + B * 119538) &gt;&gt; 20</p>
<p>这些精度实际上是一样的：3与4、7与8、10与11、13与14、19与20</p>
<p>所以16位运算下最好的计算公式是使用7位精度，比先前那个系数缩放100倍的精度高，而且速度快</p>
<p><strong>Gray = (R * 38 + G * 75 + B * 15)  &gt;&gt; 7</strong></p>
<h3 id="灰度转伪彩色"><a href="#灰度转伪彩色" class="headerlink" title="灰度转伪彩色"></a>灰度转伪彩色</h3><p>本质就是将灰度值根据一定的比例关系转化为RGB三通道值。</p>
<p>人类能够观察到的光的波长范围是有限的，并且人类视觉有一个特点，只能分辨出二十几种灰度，也就是说即使采集到的灰度图像分辨率超级高，有上百个灰度级，但是很遗憾，人们只能看出二十几个，也就是说信息损失了五十倍。但人类视觉对彩色的分辨能力相当强，能够分辨出几千种色度。</p>
<p>以下为opencv中ColorMap提供的21种不同伪彩色：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211217143800078-164025956439339.png" alt="image-20211217143800078" style="zoom: 67%;">

<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211217143838854-164025956439340.png" alt="image-20211217143838854" style="zoom:67%;">

<p>根据源码中获得的数组对每个像素进行转换即可。</p>
<h3 id="RGB模型"><a href="#RGB模型" class="headerlink" title="RGB模型"></a>RGB模型</h3><p>图像处理中，最常用的颜色空间是RGB模型，常用于颜色显示和图像处理，三维坐标的模型形式。</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDM3MTgw,size_16,color_FFFFFF,t_70.png" alt="img" style="zoom:67%;">

<p>原点到白色顶点的中轴线是灰度线，r、g、b三分量相等，强度可以由三分量的向量表示。</p>
<p>用RGB来理解色彩、深浅、明暗变化如下：</p>
<p><strong>色彩变化：</strong> 三个坐标轴RGB最大分量顶点与黄紫青YMC色顶点的连线</p>
<p><strong>深浅变化：</strong>RGB顶点和CMY顶点到原点和白色顶点的中轴线的距离</p>
<p><strong>明暗变化：</strong>中轴线的点的位置，到原点，就偏暗，到白色顶点就偏亮</p>
<h3 id="HSV色域"><a href="#HSV色域" class="headerlink" title="HSV色域"></a>HSV色域</h3><p>这是针对用户观感的一种颜色模型，侧重于色彩表示，什么颜色、深浅如何、明暗如何。</p>
<p><strong>色调H</strong></p>
<p>用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,品红为300°；</p>
<p><strong>饱和度S</strong></p>
<p>饱和度S表示颜色接近光谱色的程度。一种颜色，可以看成是某种光谱色与白色混合的结果。其中光谱色所占的比例愈大，颜色接近光谱色的程度就愈高，颜色的饱和度也就愈高。饱和度高，颜色则深而艳。光谱色的白光成分为0，饱和度达到最高。通常取值范围为0%～100%，值越大，颜色越饱和。</p>
<p><strong>明度V</strong></p>
<p>明度表示颜色明亮的程度，对于光源色，明度值与发光体的光亮度有关；对于物体色，此值和物体的透射比或反射比有关。通常取值范围为0%（黑）到100%（白）。</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/20190713042821916.png" alt="img"><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/20190713042838269-16581337844089.png" alt="img">      </p>
<p>H是色彩</p>
<p>S是深浅， S = 0时，只有灰度</p>
<p>V是明暗，表示色彩的明亮程度</p>
<p>把RGB三维坐标的中轴线立起来，并扁化，就能形成HSV的锥形模型了。</p>
<p><strong>RGB到HSV转化模型</strong></p>
<p>首先要将图像的R、G、B三个通道的分量归一化到0 ~ 1之间。</p>
<p>我们设max为该像素点的RGB中的最大值，min为最小值，有如下公式：</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/4f18d260bc465763fed4a95044fc253d.png" alt="4f18d260bc465763fed4a95044fc253d.png"></p>
<pre class="language-C++" data-language="C++"><code class="language-C++">float max &#x3D; 0,min &#x3D; 0;

max &#x3D; retmax(R,G,B);	&#x2F;&#x2F; 计算三者的最大值
min &#x3D; retmin(R,G,B);

v &#x3D; max;

if(max &#x3D;&#x3D; 0)
    s &#x3D; 0;
else
    s &#x3D; 1 - (min &#x2F; max);

if(max &#x3D;&#x3D; min)
    h &#x3D; 0;
else if(max &#x3D;&#x3D; R &amp;&amp; G &gt;&#x3D; B)
    h &#x3D; 60 * ((G - B) &#x2F; (max - min));
else if(max &#x3D;&#x3D; R &amp;&amp; G &lt; B)
    h &#x3D; 60 * ((G - B) &#x2F; (max - min)) + 360;
else if(max &#x3D;&#x3D; G)
    h &#x3D; 60 * ((B - R) &#x2F; (max - min)) + 120;
else if(max &#x3D;&#x3D; B)
    h &#x3D; 60 * ((R - G) &#x2F; (max - min)) + 240;</code></pre>

<p><strong>HSV到RGB转化模型</strong></p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/18284ab401f777c452c89f641f2db4b4.png" alt="18284ab401f777c452c89f641f2db4b4.png"></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">float C &#x3D; 0,X &#x3D; 0,Y &#x3D; 0,Z &#x3D; 0;
int i &#x3D; 0;
float H &#x3D; h &#x2F; 1.0;
float S &#x3D; s &#x2F; 100.0;
float V &#x3D; v &#x2F; 100.0;

if(S &#x3D;&#x3D; 0)
    R &#x3D; G &#x3D; B &#x3D; V;
else
&#123;
    H &#x3D; H &#x2F; 60;
    i &#x3D; (int)H;
    C &#x3D; H - i;

    X &#x3D; V * (1 - S);
    Y &#x3D; V * (1 - S * C);
    Z &#x3D; V * (1 - S * (1 - C));
    switch(i)&#123;
        case 0 : R &#x3D; V; G &#x3D; Z; B &#x3D; X; break;
        case 1 : R &#x3D; Y; G &#x3D; V; B &#x3D; X; break;
        case 2 : R &#x3D; X; G &#x3D; V; B &#x3D; Z; break;
        case 3 : R &#x3D; X; G &#x3D; Y; B &#x3D; V; break;
        case 4 : R &#x3D; Z; G &#x3D; X; B &#x3D; V; break;
        case 5 : R &#x3D; V; G &#x3D; X; B &#x3D; Y; break;
    &#125;
&#125;</code></pre>



<h3 id="差影法"><a href="#差影法" class="headerlink" title="差影法"></a>差影法</h3><p>原理上来说就是两幅图像作差对应的像素点之间作差。</p>
<p>常用于判断两幅角度相同的相似图像之间的差别。</p>
<p>可以通过对差值乘以一个倍数，实现放大差别的效果。</p>
<p>是否对差值使用绝对值计算，对作差的结果有一定影响。</p>
<h2 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h2><h3 id="普通二值化"><a href="#普通二值化" class="headerlink" title="普通二值化"></a>普通二值化</h3><p>遍历判断图像每个像素点的值，如果大于设定的阈值，则修改为255，如果小于，则修改为0。</p>
<h3 id="大津法二值化"><a href="#大津法二值化" class="headerlink" title="大津法二值化"></a>大津法二值化</h3><p>图像分割中阈值选取的最佳算法，计算简单，<strong>不受图像亮度和对比度的影响</strong>。它是按图像的灰度特性，将图像分成背景和前景两部分。因方差是灰度分布均匀性的一种度量，背景和前景之间的类间方差越大，说明构成图像的两部分的差别越大，当部分前景错分为背景或部分背景错分为前景都会导致两部分差别变小。因此,使类间方差最大的分割意味着<strong>错分概率最小</strong>。</p>
<p><strong>优点</strong>：计算简单快速，不受图像亮度和对比度的影响。适用于大部分需要求图像全局阈值的场合。</p>
<p><strong>缺点</strong>：对图像噪声敏感；只能针对单一目标分割；当目标和背景大小比例悬殊、类间方差函数可能呈现双峰或者多峰，这个时候效果不好。</p>
<p><strong>实现原理</strong></p>
<p>同样用到了最大类间方差的概念，参考下面双阈值三值化，不再多叙述。</p>
<p>注：</p>
<p>为了快速计算，可将类间方差计算公式：σ^2 = p1 * ( m1 - mg ) ^ 2 + p2 * ( m2 - mg ) ^ 2 </p>
<p>简化为：<strong>σ^2 = p1 * p2 * ( m1 - m2 ) ^ 2</strong> </p>
<h3 id="双阈值三值化"><a href="#双阈值三值化" class="headerlink" title="双阈值三值化"></a>双阈值三值化</h3><p>首先获取图像像素的直方图，即像素值为0<del>255的点分别有几个，并分别计算它们占总像素点数的比例（即一个点为该像素值的概率，Pi（i=0</del>255））。</p>
<p>其次设定两个阈值k1和k2，将0<del>255分为三类（0</del>k1，k1<del>k2，k2</del>255），计算：</p>
<p>一个点被分为其中一类的概率，表现为该类像素范围内概率的和。</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211223190634131-164025956439341.png" alt="image-20211223190634131" style="zoom:60%;">

<p>这三类各自的像素均值，表现为：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211214201512456-164025956439342.png" alt="image-20211214201512456" style="zoom:50%;">

<p>于是有：<strong>mg = p1 * m1 + p2 * m2 + p3 * m3</strong>，且 p1+p2+p3 = 1</p>
<p>可得<strong>类间方差：</strong>（更多或更少类均同理）</p>
<p><strong>σ^2 = p1 * ( m1 - mg ) ^ 2 + p2 * ( m2 - mg ) ^ 2 + p3 * ( m3 - mg ) ^ 2</strong></p>
<p>最终目的是为了获得当类间方差最大时的<strong>k1和k2</strong></p>
<p>最后只需要判断每个像素点的值在这三类中的哪类，分别修改值为0，128，255即可。</p>
<p>因此代码实现为：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">for (k1 &#x3D; 1; k1 &lt; 256; k1++)&#123;
    for (k2 &#x3D; 1; k2 &lt; 256; k2++)&#123;
        for (int i &#x3D; 0; i &lt; k1; i++)&#123;
            p1 +&#x3D; Pi;
            m1 +&#x3D; i * Pi;
        &#125;
        for (int i &#x3D; k1; i &lt; k2; i++)&#123;
            p2 +&#x3D; Pi;
            m2 +&#x3D; i * Pi;
        &#125;
        for (int i &#x3D; k2; i &lt; 256; i++)&#123;
            p3 +&#x3D; Pi;
            m3 +&#x3D; i * Pi;
        &#125;
        mg &#x3D; m1 + m2 + m3;
        m1 &#x2F;&#x3D; p1;
        m2 &#x2F;&#x3D; p2;
        m3 &#x2F;&#x3D; p3;
        &#x2F;&#x2F; 类间方差
        double sigma &#x3D; p1 * pow(m1 - mg, 2) + p2 * pow(m2 - mg, 2) + p3 * pow(m3 - mg, 2);
        if (max &lt; sigma)&#123;
            max &#x3D; sigma;
            thres1 &#x3D; k1;
            thres2 &#x3D; k2;
        &#125;
    &#125;
&#125;</code></pre>



<h2 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h2><h3 id="图像的缩放"><a href="#图像的缩放" class="headerlink" title="图像的缩放"></a>图像的缩放</h3><h4 id="最近邻插值"><a href="#最近邻插值" class="headerlink" title="最近邻插值"></a>最近邻插值</h4><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211215203920356-164025956439343.png" alt="image-20211215203920356" style="zoom:50%;">

<p>由于<strong>缩放比例</strong>（即srcWidth / dstWidth）基本上是浮点数值，而最后得到的<strong>图像坐标</strong>（srcX）是整数。因此需要对等式右边的值进行四舍五入的操作：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">int srcX &#x3D; static_cast&lt;int&gt;(dstX * (srcWidth &#x2F; dstWidth) + 0.5f);
&#x2F;&#x2F; 其中static_cast用于强制转换为int类型
&#x2F;&#x2F; +0.5f是为了实现四舍五入而不是舍去小数点后的值</code></pre>

<p>这种方法在放大图像时容易导致图像的严重失真，根源在于当坐标是浮点数时直接四舍五入取最近的整数。</p>
<h4 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h4><p><strong>线性插值的解释</strong></p>
<p>已知数据 (x0, y0) 与 (x1, y1)，要计算 [x0, x1] 区间内某一位置 x 在直线上的y值。</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/../../../../Notes/img/image-20211215211157981.png" alt="image-20211215211157981" style="zoom: 33%;"><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211215211234352-164025956439345.png" alt="image-20211215211234352" style="zoom:50%;"></p>
<p>双线性插值是有两个变量的插值函数的线性插值扩展，其核心思想是在两个方向分别进行一次线性插值。如下图：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211215211408942-164025956439346.png" alt="image-20211215211408942" style="zoom:50%;">

<p>假如我们想得到未知函数 f 在点 P = (x, y) 的值，假设我们已知函数 f 在 Q11 = (x1, y1)、Q12 = (x1, y2), Q21 = (x2, y1) 以及 Q22 = (x2, y2) 四个点的值。最常见的情况，f就是一个像素点的像素值。首先在 x 方向进行线性插值，得到：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211215211459010-164025956439347.png" alt="image-20211215211459010" style="zoom: 33%;">

<p>然后在上述基础上（R1和R2），在 y 方向进行线性插值，得到：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211215211555916-164025956439348.png" alt="image-20211215211555916" style="zoom:33%;">

<p>展开即为最终结果：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211215211649737-164025956439449.png" alt="image-20211215211649737" style="zoom:50%;">

<p><strong>代码实现</strong></p>
<p>由于图像双线性插值只会用相邻的4个点，因此上述公式的分母都是1。opencv中的源码如下，用了一些优化手段：</p>
<p><strong>用整数计算代替float</strong>（下面代码中的 * 2048就是变11位小数为整数，最后有两个连乘，因此&gt;&gt;22位）</p>
<p><strong>源图像和目标图像几何中心的对齐</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">SrcX&#x3D;(dstX + 0.5) * (srcWidth&#x2F;dstWidth) -0.5
SrcY&#x3D;(dstY + 0.5) * (srcHeight&#x2F;dstHeight) - 0.5</code></pre>

<p>源图像和目标图像的原点（0，0）均选择左上角，然后根据插值公式计算目标图像每点像素，假设你需要将一幅5x5的图像缩小成3x3，那么源图像和目标图像各个像素之间的对应关系如下。如果没有这个中心对齐，根据基本公式去算，就会得到左边这样的结果；而用了对齐，就会得到右边的结果：</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211215212542008-164025956439450.png" alt="image-20211215212542008" style="zoom: 50%;">



<h4 id="双立方插值"><a href="#双立方插值" class="headerlink" title="双立方插值"></a>双立方插值</h4><h4 id="邻域像素再取样插值"><a href="#邻域像素再取样插值" class="headerlink" title="邻域像素再取样插值"></a>邻域像素再取样插值</h4><h4 id="lanczos插值"><a href="#lanczos插值" class="headerlink" title="lanczos插值"></a>lanczos插值</h4><h3 id="图像的旋转"><a href="#图像的旋转" class="headerlink" title="图像的旋转"></a>图像的旋转</h3><p>旋转矩阵的计算原理参考：</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211216185301847-164025956439451.png" alt="image-20211216185301847"></p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211216185333652-164025956439452.png" alt="image-20211216185333652"></p>
<p><strong>实现方法：</strong></p>
<p><strong>采用反向映射。</strong>即从旋转后的图像出发，找到对应的原图像的点，然后将原图像中的灰度值传递过来即可，这样旋转后的图像的每个像素肯定可以对应到原图像中的一个点。</p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/mapping-164025956439453.png" alt="img" style="zoom:78%;">

<p>采用不同的策略算法可以使像素更加准确，*具体参照<strong>图像缩放</strong>中的各种插值法，在旋转中是同理。</p>
<h3 id="直线拟合"><a href="#直线拟合" class="headerlink" title="直线拟合"></a>直线拟合</h3><p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211216201057227-164025956439454.png" alt="image-20211216201057227"></p>
<p>这里只记录最常用的一种：<strong>最小二乘拟合算法</strong></p>
<img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/image-20211216201558546-164025956439455.png" alt="image-20211216201558546" style="zoom: 50%;">

<p>这种方法是以<strong>距离平方和</strong>为拟合判据，运行速度也最快。但是这个算法也有个很大的问题，就是当干扰点离直线较远时，一个干扰点就可能将整条拟合直线拉偏了。简单的说就是对干扰点的鲁棒性不够。</p>
<p><strong>代码实现</strong></p>
<p>假设直线表达式为：<strong>y = ax + b</strong>，a表示斜率，b表示截距。</p>
<p>对于等精度测量所得到的N组数据（xi，yi），i＝1，2……，N，其中xi值被认为是准确的，所有的误差只联系着yi；用最小二乘法估计参数时，要求观测值yi的偏差的加权平方和为最小。对于等精度观测值的直线拟合来说，可使下式的值最小：</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/1229247-20170831162433499-1199684995-164025956439456.png" alt="img"></p>
<p>令上式等于D，并分别对a，b求一阶偏导数：</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/1229247-20170831162808562-1511107057-164025956439457.png" alt="img"></p>
<p>再求二阶偏导数：</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/1229247-20170831162932452-566743597-164025956439458.png" alt="img"></p>
<p>很显然二阶偏导数均为<strong>非负数</strong>，于是令一阶偏导数等于0，解得a和b：</p>
<p><img src="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/1229247-20170831163153827-745964205-164025956439459.png" alt="img"></p>
<p>若要转化成<strong>方向向量</strong>：</p>
<p>因为方向向量长度为1且起点为原点，所以易得：<strong>x^2 + a * x^2 = 1</strong>，解得：</p>
<p>**x = 1 / sqrt( a^2 + 1 ) **</p>
<p>**y = a / sqrt( a^2 + 1 ) ** 即为方向向量。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/opencv/">opencv</a><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%83%8F/">图像</a></div><div class="post_share"><div class="social-share" data-image="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/%E5%8E%9F%E7%90%86/%E5%9F%BA%E4%BA%8ESTM32F103%E7%9A%84%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><img class="prev-cover" src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">基于STM32F103的实时操作系统</div></div></a></div><div class="next-post pull-right"><a href="/%E6%9D%82%E8%AE%B0/opencv%E7%A7%BB%E5%BA%93%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">opencv移库笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/%E6%9D%82%E8%AE%B0/opencv%E7%A7%BB%E5%BA%93%E7%AC%94%E8%AE%B0/" title="opencv移库笔记"><img class="cover" src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-23</div><div class="title">opencv移库笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Szh</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/shen962806862"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临 我的快乐</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F"><span class="toc-number">1.</span> <span class="toc-text">图像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.1.</span> <span class="toc-text">低通滤波</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E5%9F%9F%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.1.1.</span> <span class="toc-text">邻域滤波</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.1.2.</span> <span class="toc-text">中值滤波</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.1.3.</span> <span class="toc-text">自适应中值滤波</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.1.4.</span> <span class="toc-text">均值滤波</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">算术均值滤波</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">几何均值滤波</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%90%E6%B3%A2%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">谐波均值滤波</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E8%B0%90%E6%B3%A2%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">逆谐波均值滤波</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%AD%A3%E5%90%8E%E7%9A%84alpha%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">修正后的alpha均值滤波</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%80%BC%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.1.5.</span> <span class="toc-text">最值滤波</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">最大值和最小值滤波</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%82%B9%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">中点滤波</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.1.6.</span> <span class="toc-text">双边滤波</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.1.7.</span> <span class="toc-text">高斯滤波</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%80%9A%E6%BB%A4%E6%B3%A2%EF%BC%88%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">高通滤波（边缘检测）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Roberts%E7%AE%97%E5%AD%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">Roberts算子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sobel%E7%AE%97%E5%AD%90%EF%BC%88%E4%B8%80%E9%98%B6%E5%AF%BC%E6%95%B0%E6%B3%95%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">Sobel算子（一阶导数法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prewitt%E7%AE%97%E5%AD%90"><span class="toc-number">1.2.3.</span> <span class="toc-text">Prewitt算子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Laplacian%E7%AE%97%E5%AD%90%EF%BC%88%E4%BA%8C%E9%98%B6%E5%BE%AE%E5%88%86%E6%B3%95%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">Laplacian算子（二阶微分法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Canny%E7%AE%97%E5%AD%90"><span class="toc-number">1.2.5.</span> <span class="toc-text">Canny算子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%90%91%E7%AE%97%E5%AD%90"><span class="toc-number">1.2.6.</span> <span class="toc-text">方向算子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Kirsch%E7%AE%97%E5%AD%90"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">Kirsch算子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nevitia%E7%AE%97%E5%AD%90"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">Nevitia算子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%A2%E6%80%81%E5%AD%A6"><span class="toc-number">1.3.</span> <span class="toc-text">形态学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%86%A8%E8%83%80"><span class="toc-number">1.3.1.</span> <span class="toc-text">膨胀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%85%90%E8%9A%80"><span class="toc-number">1.3.2.</span> <span class="toc-text">腐蚀</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2"><span class="toc-number">1.4.</span> <span class="toc-text">霍夫变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E7%BA%BF%E6%A3%80%E6%B5%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">直线检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">标准霍夫变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%AF%E8%AE%A1%E6%A6%82%E7%8E%87%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">累计概率霍夫变换（常用）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%A0%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">池化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E5%9D%87%E6%B1%A0%E5%8C%96%EF%BC%88mean-pooling%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">平均池化（mean-pooling）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B1%A0%E5%8C%96%EF%BC%88max-pooling%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">最大池化（max-pooling）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%B1%A0%E5%8C%96%EF%BC%88stochastic-pooling%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">随机池化（stochastic-pooling）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2"><span class="toc-number">1.6.</span> <span class="toc-text">颜色</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%AE%E5%BA%A6%E4%B8%8E%E5%AF%B9%E6%AF%94%E5%BA%A6"><span class="toc-number">1.6.1.</span> <span class="toc-text">亮度与对比度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%80%A7%E5%8F%98%E5%8C%96"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">基础线性变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">改进</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%B7%B7%E5%90%88"><span class="toc-number">1.6.2.</span> <span class="toc-text">通道混合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gamma%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A0%A1%E6%AD%A3%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">gamma变换（校正）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E5%BD%92%E4%B8%80%E5%8C%96"><span class="toc-number">1.6.4.</span> <span class="toc-text">图像的归一化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E5%9D%87%E8%A1%A1%E5%8C%96"><span class="toc-number">1.6.5.</span> <span class="toc-text">图像的均衡化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RGB%E8%BD%AC%E7%81%B0%E5%BA%A6"><span class="toc-number">1.6.6.</span> <span class="toc-text">RGB转灰度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%81%B0%E5%BA%A6%E8%BD%AC%E4%BC%AA%E5%BD%A9%E8%89%B2"><span class="toc-number">1.6.7.</span> <span class="toc-text">灰度转伪彩色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RGB%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.8.</span> <span class="toc-text">RGB模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HSV%E8%89%B2%E5%9F%9F"><span class="toc-number">1.6.9.</span> <span class="toc-text">HSV色域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%BD%B1%E6%B3%95"><span class="toc-number">1.6.10.</span> <span class="toc-text">差影法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%80%BC%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">二值化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E4%BA%8C%E5%80%BC%E5%8C%96"><span class="toc-number">1.7.1.</span> <span class="toc-text">普通二值化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%B4%A5%E6%B3%95%E4%BA%8C%E5%80%BC%E5%8C%96"><span class="toc-number">1.7.2.</span> <span class="toc-text">大津法二值化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%98%88%E5%80%BC%E4%B8%89%E5%80%BC%E5%8C%96"><span class="toc-number">1.7.3.</span> <span class="toc-text">双阈值三值化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2"><span class="toc-number">1.8.</span> <span class="toc-text">几何变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E7%BC%A9%E6%94%BE"><span class="toc-number">1.8.1.</span> <span class="toc-text">图像的缩放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E9%82%BB%E6%8F%92%E5%80%BC"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">最近邻插值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">双线性插值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%AB%8B%E6%96%B9%E6%8F%92%E5%80%BC"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">双立方插值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E5%9F%9F%E5%83%8F%E7%B4%A0%E5%86%8D%E5%8F%96%E6%A0%B7%E6%8F%92%E5%80%BC"><span class="toc-number">1.8.1.4.</span> <span class="toc-text">邻域像素再取样插值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lanczos%E6%8F%92%E5%80%BC"><span class="toc-number">1.8.1.5.</span> <span class="toc-text">lanczos插值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E6%97%8B%E8%BD%AC"><span class="toc-number">1.8.2.</span> <span class="toc-text">图像的旋转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E7%BA%BF%E6%8B%9F%E5%90%88"><span class="toc-number">1.8.3.</span> <span class="toc-text">直线拟合</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E5%8E%9F%E7%90%86/%E5%85%B3%E4%BA%8Ejs%E8%B7%A8%E6%BA%90%E8%AF%B7%E6%B1%82%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="关于js跨源请求的解决方案"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于js跨源请求的解决方案"/></a><div class="content"><a class="title" href="/%E5%8E%9F%E7%90%86/%E5%85%B3%E4%BA%8Ejs%E8%B7%A8%E6%BA%90%E8%AF%B7%E6%B1%82%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="关于js跨源请求的解决方案">关于js跨源请求的解决方案</a><time datetime="2022-04-17T15:32:36.000Z" title="发表于 2022-04-17 23:32:36">2022-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%8E%9F%E7%90%86/%E5%9F%BA%E4%BA%8ESTM32F103%E7%9A%84%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="基于STM32F103的实时操作系统"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于STM32F103的实时操作系统"/></a><div class="content"><a class="title" href="/%E5%8E%9F%E7%90%86/%E5%9F%BA%E4%BA%8ESTM32F103%E7%9A%84%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="基于STM32F103的实时操作系统">基于STM32F103的实时操作系统</a><time datetime="2022-04-08T05:41:30.000Z" title="发表于 2022-04-08 13:41:30">2022-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/" title="opencv图像算法"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="opencv图像算法"/></a><div class="content"><a class="title" href="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/" title="opencv图像算法">opencv图像算法</a><time datetime="2021-12-23T11:36:24.000Z" title="发表于 2021-12-23 19:36:24">2021-12-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Szh</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/prismjs@1/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>